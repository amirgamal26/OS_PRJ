
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001528  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000048  00800060  00001528  000015bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045e  008000a8  008000a8  00001604  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001604  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001634  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002c8  00000000  00000000  00001670  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002ec4  00000000  00000000  00001938  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000107d  00000000  00000000  000047fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b8b  00000000  00000000  00005879  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006a4  00000000  00000000  00007404  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000105c  00000000  00000000  00007aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002289  00000000  00000000  00008b04  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000250  00000000  00000000  0000ad8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 95 06 	jmp	0xd2a	; 0xd2a <__vector_7>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	b6 03       	fmuls	r19, r22
      56:	bb 03       	fmulsu	r19, r19
      58:	bf 03       	fmulsu	r19, r23
      5a:	c4 03       	fmuls	r20, r20
      5c:	c8 03       	fmulsu	r20, r16
      5e:	cd 03       	fmulsu	r20, r21
      60:	d1 03       	fmuls	r21, r17
      62:	d6 03       	fmuls	r21, r22
      64:	da 03       	fmulsu	r21, r18
      66:	df 03       	fmulsu	r21, r23

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf e5       	ldi	r28, 0x5F	; 95
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	10 e0       	ldi	r17, 0x00	; 0
      76:	a0 e6       	ldi	r26, 0x60	; 96
      78:	b0 e0       	ldi	r27, 0x00	; 0
      7a:	e8 e2       	ldi	r30, 0x28	; 40
      7c:	f5 e1       	ldi	r31, 0x15	; 21
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a8 3a       	cpi	r26, 0xA8	; 168
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a8 ea       	ldi	r26, 0xA8	; 168
      8e:	b0 e0       	ldi	r27, 0x00	; 0
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a6 30       	cpi	r26, 0x06	; 6
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 03 05 	call	0xa06	; 0xa06 <main>
      9e:	0c 94 92 0a 	jmp	0x1524	; 0x1524 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <ADC_voidInit>:

void ADC_voidInit(void)
{

	/* Select the Voltage reference AVCC */
	CLR_BIT(ADMUX,ADMUX_REFS1);
      a6:	87 b1       	in	r24, 0x07	; 7
      a8:	8f 77       	andi	r24, 0x7F	; 127
      aa:	87 b9       	out	0x07, r24	; 7
	SET_BIT(ADMUX,ADMUX_REFS0);
      ac:	87 b1       	in	r24, 0x07	; 7
      ae:	80 64       	ori	r24, 0x40	; 64
      b0:	87 b9       	out	0x07, r24	; 7

	/* Select the right Adjustment */
	CLR_BIT(ADMUX,ADMUX_ADLAR);
      b2:	87 b1       	in	r24, 0x07	; 7
      b4:	8f 7d       	andi	r24, 0xDF	; 223
      b6:	87 b9       	out	0x07, r24	; 7
	/* Select The Prescaler value => 64 */
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
      b8:	86 b1       	in	r24, 0x06	; 6
      ba:	84 60       	ori	r24, 0x04	; 4
      bc:	86 b9       	out	0x06, r24	; 6
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	82 60       	ori	r24, 0x02	; 2
      c2:	86 b9       	out	0x06, r24	; 6
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
      c4:	86 b1       	in	r24, 0x06	; 6
      c6:	8e 7f       	andi	r24, 0xFE	; 254
      c8:	86 b9       	out	0x06, r24	; 6

	/* Enable ADC peripheral */
	SET_BIT(ADCSRA,ADCSRA_ADEN);
      ca:	86 b1       	in	r24, 0x06	; 6
      cc:	80 68       	ori	r24, 0x80	; 128
      ce:	86 b9       	out	0x06, r24	; 6
      d0:	08 95       	ret

000000d2 <ADC_u16GetDigitalValue>:

}

void  ADC_u16GetDigitalValue (u8 Copy_u8ChannelNb,u16 *ptr)
{
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	eb 01       	movw	r28, r22
	/* Clear The Channel Number bits */
		ADMUX &= (ADMUX_CHANNEL_NUM_MASK);
      d8:	97 b1       	in	r25, 0x07	; 7
      da:	90 7e       	andi	r25, 0xE0	; 224
      dc:	97 b9       	out	0x07, r25	; 7
		/* Select The Channel Number */
		ADMUX |= Copy_u8ChannelNb;
      de:	97 b1       	in	r25, 0x07	; 7
      e0:	89 2b       	or	r24, r25
      e2:	87 b9       	out	0x07, r24	; 7

		/* Start Conversion */
		SET_BIT(ADCSRA,ADCSRA_ADSC);
      e4:	86 b1       	in	r24, 0x06	; 6
      e6:	80 64       	ori	r24, 0x40	; 64
      e8:	86 b9       	out	0x06, r24	; 6

		/* Polling on the flag */
		//while(GET_BIT(ADCSRA,ADCSRA_ADIF) == 0);
		vTaskDelay(1);
      ea:	81 e0       	ldi	r24, 0x01	; 1
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
		/* Clear Flag */
		SET_BIT(ADCSRA,ADCSRA_ADIF);
      f2:	86 b1       	in	r24, 0x06	; 6
      f4:	80 61       	ori	r24, 0x10	; 16
      f6:	86 b9       	out	0x06, r24	; 6

		/* Read the ADC value */
		*ptr= ADC;
      f8:	84 b1       	in	r24, 0x04	; 4
      fa:	95 b1       	in	r25, 0x05	; 5
      fc:	99 83       	std	Y+1, r25	; 0x01
      fe:	88 83       	st	Y, r24
}
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	08 95       	ret

00000106 <DIO_u8SetPinValue>:
		}
	}
	else
		local_u8ErorrState=STD_TYPES_NOK;
	return local_u8ErorrState;
}
     106:	84 30       	cpi	r24, 0x04	; 4
     108:	08 f0       	brcs	.+2      	; 0x10c <DIO_u8SetPinValue+0x6>
     10a:	87 c0       	rjmp	.+270    	; 0x21a <DIO_u8SetPinValue+0x114>
     10c:	68 30       	cpi	r22, 0x08	; 8
     10e:	08 f0       	brcs	.+2      	; 0x112 <DIO_u8SetPinValue+0xc>
     110:	86 c0       	rjmp	.+268    	; 0x21e <DIO_u8SetPinValue+0x118>
     112:	42 30       	cpi	r20, 0x02	; 2
     114:	08 f0       	brcs	.+2      	; 0x118 <DIO_u8SetPinValue+0x12>
     116:	85 c0       	rjmp	.+266    	; 0x222 <DIO_u8SetPinValue+0x11c>
     118:	81 30       	cpi	r24, 0x01	; 1
     11a:	31 f1       	breq	.+76     	; 0x168 <DIO_u8SetPinValue+0x62>
     11c:	38 f0       	brcs	.+14     	; 0x12c <DIO_u8SetPinValue+0x26>
     11e:	82 30       	cpi	r24, 0x02	; 2
     120:	09 f4       	brne	.+2      	; 0x124 <DIO_u8SetPinValue+0x1e>
     122:	40 c0       	rjmp	.+128    	; 0x1a4 <DIO_u8SetPinValue+0x9e>
     124:	83 30       	cpi	r24, 0x03	; 3
     126:	09 f4       	brne	.+2      	; 0x12a <DIO_u8SetPinValue+0x24>
     128:	5b c0       	rjmp	.+182    	; 0x1e0 <DIO_u8SetPinValue+0xda>
     12a:	7d c0       	rjmp	.+250    	; 0x226 <DIO_u8SetPinValue+0x120>
     12c:	44 23       	and	r20, r20
     12e:	79 f0       	breq	.+30     	; 0x14e <DIO_u8SetPinValue+0x48>
     130:	41 30       	cpi	r20, 0x01	; 1
     132:	09 f0       	breq	.+2      	; 0x136 <DIO_u8SetPinValue+0x30>
     134:	7a c0       	rjmp	.+244    	; 0x22a <DIO_u8SetPinValue+0x124>
     136:	2b b3       	in	r18, 0x1b	; 27
     138:	81 e0       	ldi	r24, 0x01	; 1
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	02 c0       	rjmp	.+4      	; 0x142 <DIO_u8SetPinValue+0x3c>
     13e:	88 0f       	add	r24, r24
     140:	99 1f       	adc	r25, r25
     142:	6a 95       	dec	r22
     144:	e2 f7       	brpl	.-8      	; 0x13e <DIO_u8SetPinValue+0x38>
     146:	82 2b       	or	r24, r18
     148:	8b bb       	out	0x1b, r24	; 27
     14a:	80 e0       	ldi	r24, 0x00	; 0
     14c:	08 95       	ret
     14e:	2b b3       	in	r18, 0x1b	; 27
     150:	81 e0       	ldi	r24, 0x01	; 1
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	02 c0       	rjmp	.+4      	; 0x15a <DIO_u8SetPinValue+0x54>
     156:	88 0f       	add	r24, r24
     158:	99 1f       	adc	r25, r25
     15a:	6a 95       	dec	r22
     15c:	e2 f7       	brpl	.-8      	; 0x156 <DIO_u8SetPinValue+0x50>
     15e:	80 95       	com	r24
     160:	82 23       	and	r24, r18
     162:	8b bb       	out	0x1b, r24	; 27
     164:	80 e0       	ldi	r24, 0x00	; 0
     166:	08 95       	ret
     168:	44 23       	and	r20, r20
     16a:	79 f0       	breq	.+30     	; 0x18a <DIO_u8SetPinValue+0x84>
     16c:	41 30       	cpi	r20, 0x01	; 1
     16e:	09 f0       	breq	.+2      	; 0x172 <DIO_u8SetPinValue+0x6c>
     170:	5e c0       	rjmp	.+188    	; 0x22e <DIO_u8SetPinValue+0x128>
     172:	28 b3       	in	r18, 0x18	; 24
     174:	81 e0       	ldi	r24, 0x01	; 1
     176:	90 e0       	ldi	r25, 0x00	; 0
     178:	02 c0       	rjmp	.+4      	; 0x17e <DIO_u8SetPinValue+0x78>
     17a:	88 0f       	add	r24, r24
     17c:	99 1f       	adc	r25, r25
     17e:	6a 95       	dec	r22
     180:	e2 f7       	brpl	.-8      	; 0x17a <DIO_u8SetPinValue+0x74>
     182:	82 2b       	or	r24, r18
     184:	88 bb       	out	0x18, r24	; 24
     186:	80 e0       	ldi	r24, 0x00	; 0
     188:	08 95       	ret
     18a:	28 b3       	in	r18, 0x18	; 24
     18c:	81 e0       	ldi	r24, 0x01	; 1
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	02 c0       	rjmp	.+4      	; 0x196 <DIO_u8SetPinValue+0x90>
     192:	88 0f       	add	r24, r24
     194:	99 1f       	adc	r25, r25
     196:	6a 95       	dec	r22
     198:	e2 f7       	brpl	.-8      	; 0x192 <DIO_u8SetPinValue+0x8c>
     19a:	80 95       	com	r24
     19c:	82 23       	and	r24, r18
     19e:	88 bb       	out	0x18, r24	; 24
     1a0:	80 e0       	ldi	r24, 0x00	; 0
     1a2:	08 95       	ret
     1a4:	44 23       	and	r20, r20
     1a6:	79 f0       	breq	.+30     	; 0x1c6 <DIO_u8SetPinValue+0xc0>
     1a8:	41 30       	cpi	r20, 0x01	; 1
     1aa:	09 f0       	breq	.+2      	; 0x1ae <DIO_u8SetPinValue+0xa8>
     1ac:	42 c0       	rjmp	.+132    	; 0x232 <DIO_u8SetPinValue+0x12c>
     1ae:	25 b3       	in	r18, 0x15	; 21
     1b0:	81 e0       	ldi	r24, 0x01	; 1
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	02 c0       	rjmp	.+4      	; 0x1ba <DIO_u8SetPinValue+0xb4>
     1b6:	88 0f       	add	r24, r24
     1b8:	99 1f       	adc	r25, r25
     1ba:	6a 95       	dec	r22
     1bc:	e2 f7       	brpl	.-8      	; 0x1b6 <DIO_u8SetPinValue+0xb0>
     1be:	82 2b       	or	r24, r18
     1c0:	85 bb       	out	0x15, r24	; 21
     1c2:	80 e0       	ldi	r24, 0x00	; 0
     1c4:	08 95       	ret
     1c6:	25 b3       	in	r18, 0x15	; 21
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	90 e0       	ldi	r25, 0x00	; 0
     1cc:	02 c0       	rjmp	.+4      	; 0x1d2 <DIO_u8SetPinValue+0xcc>
     1ce:	88 0f       	add	r24, r24
     1d0:	99 1f       	adc	r25, r25
     1d2:	6a 95       	dec	r22
     1d4:	e2 f7       	brpl	.-8      	; 0x1ce <DIO_u8SetPinValue+0xc8>
     1d6:	80 95       	com	r24
     1d8:	82 23       	and	r24, r18
     1da:	85 bb       	out	0x15, r24	; 21
     1dc:	80 e0       	ldi	r24, 0x00	; 0
     1de:	08 95       	ret
     1e0:	44 23       	and	r20, r20
     1e2:	71 f0       	breq	.+28     	; 0x200 <DIO_u8SetPinValue+0xfa>
     1e4:	41 30       	cpi	r20, 0x01	; 1
     1e6:	39 f5       	brne	.+78     	; 0x236 <DIO_u8SetPinValue+0x130>
     1e8:	22 b3       	in	r18, 0x12	; 18
     1ea:	81 e0       	ldi	r24, 0x01	; 1
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	02 c0       	rjmp	.+4      	; 0x1f4 <DIO_u8SetPinValue+0xee>
     1f0:	88 0f       	add	r24, r24
     1f2:	99 1f       	adc	r25, r25
     1f4:	6a 95       	dec	r22
     1f6:	e2 f7       	brpl	.-8      	; 0x1f0 <DIO_u8SetPinValue+0xea>
     1f8:	82 2b       	or	r24, r18
     1fa:	82 bb       	out	0x12, r24	; 18
     1fc:	80 e0       	ldi	r24, 0x00	; 0
     1fe:	08 95       	ret
     200:	22 b3       	in	r18, 0x12	; 18
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	02 c0       	rjmp	.+4      	; 0x20c <DIO_u8SetPinValue+0x106>
     208:	88 0f       	add	r24, r24
     20a:	99 1f       	adc	r25, r25
     20c:	6a 95       	dec	r22
     20e:	e2 f7       	brpl	.-8      	; 0x208 <DIO_u8SetPinValue+0x102>
     210:	80 95       	com	r24
     212:	82 23       	and	r24, r18
     214:	82 bb       	out	0x12, r24	; 18
     216:	80 e0       	ldi	r24, 0x00	; 0
     218:	08 95       	ret
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	08 95       	ret
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	08 95       	ret
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	08 95       	ret
     226:	80 e0       	ldi	r24, 0x00	; 0
     228:	08 95       	ret
     22a:	80 e0       	ldi	r24, 0x00	; 0
     22c:	08 95       	ret
     22e:	80 e0       	ldi	r24, 0x00	; 0
     230:	08 95       	ret
     232:	80 e0       	ldi	r24, 0x00	; 0
     234:	08 95       	ret
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	08 95       	ret

0000023a <DIO_u8GetPinValue>:
     23a:	84 30       	cpi	r24, 0x04	; 4
     23c:	08 f0       	brcs	.+2      	; 0x240 <DIO_u8GetPinValue+0x6>
     23e:	57 c0       	rjmp	.+174    	; 0x2ee <DIO_u8GetPinValue+0xb4>
     240:	68 30       	cpi	r22, 0x08	; 8
     242:	08 f0       	brcs	.+2      	; 0x246 <DIO_u8GetPinValue+0xc>
     244:	56 c0       	rjmp	.+172    	; 0x2f2 <DIO_u8GetPinValue+0xb8>
     246:	41 15       	cp	r20, r1
     248:	51 05       	cpc	r21, r1
     24a:	09 f4       	brne	.+2      	; 0x24e <DIO_u8GetPinValue+0x14>
     24c:	54 c0       	rjmp	.+168    	; 0x2f6 <DIO_u8GetPinValue+0xbc>
     24e:	81 30       	cpi	r24, 0x01	; 1
     250:	c1 f0       	breq	.+48     	; 0x282 <DIO_u8GetPinValue+0x48>
     252:	28 f0       	brcs	.+10     	; 0x25e <DIO_u8GetPinValue+0x24>
     254:	82 30       	cpi	r24, 0x02	; 2
     256:	39 f1       	breq	.+78     	; 0x2a6 <DIO_u8GetPinValue+0x6c>
     258:	83 30       	cpi	r24, 0x03	; 3
     25a:	b9 f1       	breq	.+110    	; 0x2ca <DIO_u8GetPinValue+0x90>
     25c:	4e c0       	rjmp	.+156    	; 0x2fa <DIO_u8GetPinValue+0xc0>
     25e:	89 b3       	in	r24, 0x19	; 25
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	02 c0       	rjmp	.+4      	; 0x268 <DIO_u8GetPinValue+0x2e>
     264:	95 95       	asr	r25
     266:	87 95       	ror	r24
     268:	6a 95       	dec	r22
     26a:	e2 f7       	brpl	.-8      	; 0x264 <DIO_u8GetPinValue+0x2a>
     26c:	80 ff       	sbrs	r24, 0
     26e:	05 c0       	rjmp	.+10     	; 0x27a <DIO_u8GetPinValue+0x40>
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	fa 01       	movw	r30, r20
     274:	80 83       	st	Z, r24
     276:	80 e0       	ldi	r24, 0x00	; 0
     278:	08 95       	ret
     27a:	fa 01       	movw	r30, r20
     27c:	10 82       	st	Z, r1
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	08 95       	ret
     282:	86 b3       	in	r24, 0x16	; 22
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	02 c0       	rjmp	.+4      	; 0x28c <DIO_u8GetPinValue+0x52>
     288:	95 95       	asr	r25
     28a:	87 95       	ror	r24
     28c:	6a 95       	dec	r22
     28e:	e2 f7       	brpl	.-8      	; 0x288 <DIO_u8GetPinValue+0x4e>
     290:	80 ff       	sbrs	r24, 0
     292:	05 c0       	rjmp	.+10     	; 0x29e <DIO_u8GetPinValue+0x64>
     294:	81 e0       	ldi	r24, 0x01	; 1
     296:	fa 01       	movw	r30, r20
     298:	80 83       	st	Z, r24
     29a:	80 e0       	ldi	r24, 0x00	; 0
     29c:	08 95       	ret
     29e:	fa 01       	movw	r30, r20
     2a0:	10 82       	st	Z, r1
     2a2:	80 e0       	ldi	r24, 0x00	; 0
     2a4:	08 95       	ret
     2a6:	83 b3       	in	r24, 0x13	; 19
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <DIO_u8GetPinValue+0x76>
     2ac:	95 95       	asr	r25
     2ae:	87 95       	ror	r24
     2b0:	6a 95       	dec	r22
     2b2:	e2 f7       	brpl	.-8      	; 0x2ac <DIO_u8GetPinValue+0x72>
     2b4:	80 ff       	sbrs	r24, 0
     2b6:	05 c0       	rjmp	.+10     	; 0x2c2 <DIO_u8GetPinValue+0x88>
     2b8:	81 e0       	ldi	r24, 0x01	; 1
     2ba:	fa 01       	movw	r30, r20
     2bc:	80 83       	st	Z, r24
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret
     2c2:	fa 01       	movw	r30, r20
     2c4:	10 82       	st	Z, r1
     2c6:	80 e0       	ldi	r24, 0x00	; 0
     2c8:	08 95       	ret
     2ca:	80 b3       	in	r24, 0x10	; 16
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	02 c0       	rjmp	.+4      	; 0x2d4 <DIO_u8GetPinValue+0x9a>
     2d0:	95 95       	asr	r25
     2d2:	87 95       	ror	r24
     2d4:	6a 95       	dec	r22
     2d6:	e2 f7       	brpl	.-8      	; 0x2d0 <DIO_u8GetPinValue+0x96>
     2d8:	80 ff       	sbrs	r24, 0
     2da:	05 c0       	rjmp	.+10     	; 0x2e6 <DIO_u8GetPinValue+0xac>
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	fa 01       	movw	r30, r20
     2e0:	80 83       	st	Z, r24
     2e2:	80 e0       	ldi	r24, 0x00	; 0
     2e4:	08 95       	ret
     2e6:	fa 01       	movw	r30, r20
     2e8:	10 82       	st	Z, r1
     2ea:	80 e0       	ldi	r24, 0x00	; 0
     2ec:	08 95       	ret
     2ee:	81 e0       	ldi	r24, 0x01	; 1
     2f0:	08 95       	ret
     2f2:	81 e0       	ldi	r24, 0x01	; 1
     2f4:	08 95       	ret
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	08 95       	ret
     2fa:	80 e0       	ldi	r24, 0x00	; 0
     2fc:	08 95       	ret

000002fe <DIO_u8SetPortValue>:
     2fe:	84 30       	cpi	r24, 0x04	; 4
     300:	b0 f4       	brcc	.+44     	; 0x32e <DIO_u8SetPortValue+0x30>
     302:	66 23       	and	r22, r22
     304:	b4 f0       	brlt	.+44     	; 0x332 <DIO_u8SetPortValue+0x34>
     306:	81 30       	cpi	r24, 0x01	; 1
     308:	49 f0       	breq	.+18     	; 0x31c <DIO_u8SetPortValue+0x1e>
     30a:	28 f0       	brcs	.+10     	; 0x316 <DIO_u8SetPortValue+0x18>
     30c:	82 30       	cpi	r24, 0x02	; 2
     30e:	49 f0       	breq	.+18     	; 0x322 <DIO_u8SetPortValue+0x24>
     310:	83 30       	cpi	r24, 0x03	; 3
     312:	51 f0       	breq	.+20     	; 0x328 <DIO_u8SetPortValue+0x2a>
     314:	10 c0       	rjmp	.+32     	; 0x336 <DIO_u8SetPortValue+0x38>
     316:	6b bb       	out	0x1b, r22	; 27
     318:	80 e0       	ldi	r24, 0x00	; 0
     31a:	08 95       	ret
     31c:	68 bb       	out	0x18, r22	; 24
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	08 95       	ret
     322:	65 bb       	out	0x15, r22	; 21
     324:	80 e0       	ldi	r24, 0x00	; 0
     326:	08 95       	ret
     328:	62 bb       	out	0x12, r22	; 18
     32a:	80 e0       	ldi	r24, 0x00	; 0
     32c:	08 95       	ret
     32e:	81 e0       	ldi	r24, 0x01	; 1
     330:	08 95       	ret
     332:	81 e0       	ldi	r24, 0x01	; 1
     334:	08 95       	ret
     336:	80 e0       	ldi	r24, 0x00	; 0
     338:	08 95       	ret

0000033a <DIO_Init>:


void DIO_Init(void)
{
	/*SET INTIAL DIRECTION AS INPUT*/
	DIO_u8_DDRA_REG=Conc(DIO_u8_PA7_INTIAL_DIRECTION,DIO_u8_PA6_INTIAL_DIRECTION,DIO_u8_PA5_INTIAL_DIRECTION,DIO_u8_PA4_INTIAL_DIRECTION,
     33a:	86 e0       	ldi	r24, 0x06	; 6
     33c:	8a bb       	out	0x1a, r24	; 26
						 DIO_u8_PA3_INTIAL_DIRECTION,DIO_u8_PA2_INTIAL_DIRECTION,DIO_u8_PA1_INTIAL_DIRECTION,DIO_u8_PA0_INTIAL_DIRECTION);
	DIO_u8_DDRB_REG=Conc(DIO_u8_PB7_INTIAL_DIRECTION,DIO_u8_PB6_INTIAL_DIRECTION,DIO_u8_PB5_INTIAL_DIRECTION,DIO_u8_PB4_INTIAL_DIRECTION,
     33e:	8f ef       	ldi	r24, 0xFF	; 255
     340:	87 bb       	out	0x17, r24	; 23
						 DIO_u8_PB3_INTIAL_DIRECTION,DIO_u8_PB2_INTIAL_DIRECTION,DIO_u8_PB1_INTIAL_DIRECTION,DIO_u8_PB0_INTIAL_DIRECTION);
	DIO_u8_DDRC_REG=Conc(DIO_u8_PC7_INTIAL_DIRECTION,DIO_u8_PC6_INTIAL_DIRECTION,DIO_u8_PC5_INTIAL_DIRECTION,DIO_u8_PC4_INTIAL_DIRECTION,
     342:	9f e0       	ldi	r25, 0x0F	; 15
     344:	94 bb       	out	0x14, r25	; 20
						 DIO_u8_PC3_INTIAL_DIRECTION,DIO_u8_PC2_INTIAL_DIRECTION,DIO_u8_PC1_INTIAL_DIRECTION,DIO_u8_PC0_INTIAL_DIRECTION);
	DIO_u8_DDRD_REG=Conc(DIO_u8_PD7_INTIAL_DIRECTION,DIO_u8_PD6_INTIAL_DIRECTION,DIO_u8_PD5_INTIAL_DIRECTION,DIO_u8_PD4_INTIAL_DIRECTION,
     346:	91 bb       	out	0x11, r25	; 17
						 DIO_u8_PD3_INTIAL_DIRECTION,DIO_u8_PD2_INTIAL_DIRECTION,DIO_u8_PD1_INTIAL_DIRECTION,DIO_u8_PD0_INTIAL_DIRECTION);
	
	/*SET INTIAL VALUE AS INPUT FLOAT*/
	
	DIO_u8_PORTA_REG=Conc(DIO_u8_PA7_INTIAL_VALUE,DIO_u8_PA6_INTIAL_VALUE,DIO_u8_PA5_INTIAL_VALUE,DIO_u8_PA4_INTIAL_VALUE,
     348:	1b ba       	out	0x1b, r1	; 27
						  DIO_u8_PA3_INTIAL_VALUE,DIO_u8_PA2_INTIAL_VALUE,DIO_u8_PA1_INTIAL_VALUE,DIO_u8_PA0_INTIAL_VALUE);
	DIO_u8_PORTB_REG=Conc(DIO_u8_PB7_INTIAL_VALUE,DIO_u8_PB6_INTIAL_VALUE,DIO_u8_PB5_INTIAL_VALUE,DIO_u8_PB4_INTIAL_VALUE,
     34a:	18 ba       	out	0x18, r1	; 24
						  DIO_u8_PB3_INTIAL_VALUE,DIO_u8_PB2_INTIAL_VALUE,DIO_u8_PB1_INTIAL_VALUE,DIO_u8_PB0_INTIAL_VALUE);
	DIO_u8_PORTC_REG=Conc(DIO_u8_PC7_INTIAL_VALUE,DIO_u8_PC6_INTIAL_VALUE,DIO_u8_PC5_INTIAL_VALUE,DIO_u8_PC4_INTIAL_VALUE,
     34c:	15 ba       	out	0x15, r1	; 21
						  DIO_u8_PC3_INTIAL_VALUE,DIO_u8_PC2_INTIAL_VALUE,DIO_u8_PC1_INTIAL_VALUE,DIO_u8_PC0_INTIAL_VALUE);
	DIO_u8_PORTD_REG=Conc(DIO_u8_PD7_INTIAL_VALUE,DIO_u8_PD6_INTIAL_VALUE,DIO_u8_PD5_INTIAL_VALUE,DIO_u8_PD4_INTIAL_VALUE,
     34e:	82 bb       	out	0x12, r24	; 18
     350:	08 95       	ret

00000352 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     358:	0e 94 96 08 	call	0x112c	; 0x112c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     35c:	20 91 a8 00 	lds	r18, 0x00A8	; 0x8000a8 <__data_end>
     360:	30 91 a9 00 	lds	r19, 0x00A9	; 0x8000a9 <__data_end+0x1>
     364:	c9 01       	movw	r24, r18
     366:	8c 0f       	add	r24, r28
     368:	9d 1f       	adc	r25, r29
     36a:	88 3e       	cpi	r24, 0xE8	; 232
     36c:	43 e0       	ldi	r20, 0x03	; 3
     36e:	94 07       	cpc	r25, r20
     370:	58 f4       	brcc	.+22     	; 0x388 <pvPortMalloc+0x36>
     372:	28 17       	cp	r18, r24
     374:	39 07       	cpc	r19, r25
     376:	58 f4       	brcc	.+22     	; 0x38e <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     378:	e9 01       	movw	r28, r18
     37a:	c6 55       	subi	r28, 0x56	; 86
     37c:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     37e:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__data_end+0x1>
     382:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__data_end>
     386:	05 c0       	rjmp	.+10     	; 0x392 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     388:	c0 e0       	ldi	r28, 0x00	; 0
     38a:	d0 e0       	ldi	r29, 0x00	; 0
     38c:	02 c0       	rjmp	.+4      	; 0x392 <pvPortMalloc+0x40>
     38e:	c0 e0       	ldi	r28, 0x00	; 0
     390:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     392:	0e 94 46 09 	call	0x128c	; 0x128c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     396:	ce 01       	movw	r24, r28
     398:	df 91       	pop	r29
     39a:	cf 91       	pop	r28
     39c:	08 95       	ret

0000039e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     39e:	08 95       	ret

000003a0 <KPD_u8GetKeyState>:
const u8 KPD_Au8RowsPins[4]={KPD_u8_R1_PIN,KPD_u8_R2_PIN,KPD_u8_R3_PIN,KPD_u8_R4_PIN};
const u8 KPD_Au8colsPins[4]={KPD_u8_C1_PIN,KPD_u8_C2_PIN,KPD_u8_C3_PIN,KPD_u8_C4_PIN};


u8 KPD_u8GetKeyState(u8 *copy_pu8ReturnKey)
{
     3a0:	8f 92       	push	r8
     3a2:	9f 92       	push	r9
     3a4:	af 92       	push	r10
     3a6:	bf 92       	push	r11
     3a8:	cf 92       	push	r12
     3aa:	df 92       	push	r13
     3ac:	ef 92       	push	r14
     3ae:	ff 92       	push	r15
     3b0:	0f 93       	push	r16
     3b2:	1f 93       	push	r17
     3b4:	cf 93       	push	r28
     3b6:	df 93       	push	r29
     3b8:	1f 92       	push	r1
     3ba:	cd b7       	in	r28, 0x3d	; 61
     3bc:	de b7       	in	r29, 0x3e	; 62
	u8 local_u8ErrorState=STD_TYPES_OK;
	if(copy_pu8ReturnKey!= NULL)
     3be:	00 97       	sbiw	r24, 0x00	; 0
     3c0:	09 f4       	brne	.+2      	; 0x3c4 <KPD_u8GetKeyState+0x24>
     3c2:	4c c0       	rjmp	.+152    	; 0x45c <__EEPROM_REGION_LENGTH__+0x5c>
     3c4:	5c 01       	movw	r10, r24
	{	
		*copy_pu8ReturnKey=KPD_u8_KEY_NOT_PRESSED;
     3c6:	8f ef       	ldi	r24, 0xFF	; 255
     3c8:	f5 01       	movw	r30, r10
     3ca:	80 83       	st	Z, r24
		u8 local_columnid,local_u8PinValue;
		u8 local_rowid;
		/*activation each row */
		for(local_columnid=0;local_columnid<4;local_columnid++)
     3cc:	91 2c       	mov	r9, r1
     3ce:	40 c0       	rjmp	.+128    	; 0x450 <__EEPROM_REGION_LENGTH__+0x50>
		{
			DIO_u8SetPinValue(KPD_u8_PORT,KPD_Au8colsPins[local_columnid],DIO_u8_LOW_VALUE);
     3d0:	c9 2c       	mov	r12, r9
     3d2:	d1 2c       	mov	r13, r1
     3d4:	f6 01       	movw	r30, r12
     3d6:	ee 59       	subi	r30, 0x9E	; 158
     3d8:	ff 4f       	sbci	r31, 0xFF	; 255
     3da:	80 80       	ld	r8, Z
     3dc:	40 e0       	ldi	r20, 0x00	; 0
     3de:	68 2d       	mov	r22, r8
     3e0:	83 e0       	ldi	r24, 0x03	; 3
     3e2:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
			/*check which input pin has zero */
			for(local_rowid=0;local_rowid<4;local_rowid++)
     3e6:	10 e0       	ldi	r17, 0x00	; 0
     3e8:	2b c0       	rjmp	.+86     	; 0x440 <__EEPROM_REGION_LENGTH__+0x40>
			{
				DIO_u8GetPinValue(KPD_u8_PORT,KPD_Au8RowsPins[local_rowid],&local_u8PinValue);
     3ea:	e1 2e       	mov	r14, r17
     3ec:	f1 2c       	mov	r15, r1
     3ee:	f7 01       	movw	r30, r14
     3f0:	ea 59       	subi	r30, 0x9A	; 154
     3f2:	ff 4f       	sbci	r31, 0xFF	; 255
     3f4:	00 81       	ld	r16, Z
     3f6:	ae 01       	movw	r20, r28
     3f8:	4f 5f       	subi	r20, 0xFF	; 255
     3fa:	5f 4f       	sbci	r21, 0xFF	; 255
     3fc:	60 2f       	mov	r22, r16
     3fe:	83 e0       	ldi	r24, 0x03	; 3
     400:	0e 94 1d 01 	call	0x23a	; 0x23a <DIO_u8GetPinValue>
				if(local_u8PinValue==DIO_u8_LOW_VALUE)/*switch is pressed*/
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	81 11       	cpse	r24, r1
     408:	1a c0       	rjmp	.+52     	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
				{
					/*debouncing*/
					//					_delay_ms(20);
					//					DIO_u8GetPinValue(KPD_u8_PORT,KPD_Au8RowsPins[local_rowid],&local_u8PinValue);
					/*check the bin is still equal low*/
					*copy_pu8ReturnKey=KPD_Au8Keys[local_rowid][local_columnid];
     40a:	97 01       	movw	r18, r14
     40c:	22 0f       	add	r18, r18
     40e:	33 1f       	adc	r19, r19
     410:	22 0f       	add	r18, r18
     412:	33 1f       	adc	r19, r19
     414:	26 59       	subi	r18, 0x96	; 150
     416:	3f 4f       	sbci	r19, 0xFF	; 255
     418:	f9 01       	movw	r30, r18
     41a:	ec 0d       	add	r30, r12
     41c:	fd 1d       	adc	r31, r13
     41e:	80 81       	ld	r24, Z
     420:	f5 01       	movw	r30, r10
     422:	80 83       	st	Z, r24
					while(local_u8PinValue==DIO_u8_LOW_VALUE)
     424:	07 c0       	rjmp	.+14     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
					{
						DIO_u8GetPinValue(KPD_u8_PORT,KPD_Au8RowsPins[local_rowid],&local_u8PinValue);
     426:	ae 01       	movw	r20, r28
     428:	4f 5f       	subi	r20, 0xFF	; 255
     42a:	5f 4f       	sbci	r21, 0xFF	; 255
     42c:	60 2f       	mov	r22, r16
     42e:	83 e0       	ldi	r24, 0x03	; 3
     430:	0e 94 1d 01 	call	0x23a	; 0x23a <DIO_u8GetPinValue>
					/*debouncing*/
					//					_delay_ms(20);
					//					DIO_u8GetPinValue(KPD_u8_PORT,KPD_Au8RowsPins[local_rowid],&local_u8PinValue);
					/*check the bin is still equal low*/
					*copy_pu8ReturnKey=KPD_Au8Keys[local_rowid][local_columnid];
					while(local_u8PinValue==DIO_u8_LOW_VALUE)
     434:	89 81       	ldd	r24, Y+1	; 0x01
     436:	88 23       	and	r24, r24
     438:	b1 f3       	breq	.-20     	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
					{
						DIO_u8GetPinValue(KPD_u8_PORT,KPD_Au8RowsPins[local_rowid],&local_u8PinValue);
					}
						return local_u8ErrorState;
     43a:	80 e0       	ldi	r24, 0x00	; 0
     43c:	10 c0       	rjmp	.+32     	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
		/*activation each row */
		for(local_columnid=0;local_columnid<4;local_columnid++)
		{
			DIO_u8SetPinValue(KPD_u8_PORT,KPD_Au8colsPins[local_columnid],DIO_u8_LOW_VALUE);
			/*check which input pin has zero */
			for(local_rowid=0;local_rowid<4;local_rowid++)
     43e:	1f 5f       	subi	r17, 0xFF	; 255
     440:	14 30       	cpi	r17, 0x04	; 4
     442:	98 f2       	brcs	.-90     	; 0x3ea <KPD_u8GetKeyState+0x4a>

				}
				//deactivate

			}
			DIO_u8SetPinValue(KPD_u8_PORT,KPD_Au8colsPins[local_columnid],DIO_u8_HIGH_VALUE);
     444:	41 e0       	ldi	r20, 0x01	; 1
     446:	68 2d       	mov	r22, r8
     448:	83 e0       	ldi	r24, 0x03	; 3
     44a:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
	{	
		*copy_pu8ReturnKey=KPD_u8_KEY_NOT_PRESSED;
		u8 local_columnid,local_u8PinValue;
		u8 local_rowid;
		/*activation each row */
		for(local_columnid=0;local_columnid<4;local_columnid++)
     44e:	93 94       	inc	r9
     450:	f3 e0       	ldi	r31, 0x03	; 3
     452:	f9 15       	cp	r31, r9
     454:	08 f0       	brcs	.+2      	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
     456:	bc cf       	rjmp	.-136    	; 0x3d0 <KPD_u8GetKeyState+0x30>
const u8 KPD_Au8colsPins[4]={KPD_u8_C1_PIN,KPD_u8_C2_PIN,KPD_u8_C3_PIN,KPD_u8_C4_PIN};


u8 KPD_u8GetKeyState(u8 *copy_pu8ReturnKey)
{
	u8 local_u8ErrorState=STD_TYPES_OK;
     458:	80 e0       	ldi	r24, 0x00	; 0
     45a:	01 c0       	rjmp	.+2      	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
			DIO_u8SetPinValue(KPD_u8_PORT,KPD_Au8colsPins[local_columnid],DIO_u8_HIGH_VALUE);

		}
	}		
	else
		local_u8ErrorState=STD_TYPES_NOK;
     45c:	81 e0       	ldi	r24, 0x01	; 1
	return local_u8ErrorState;
}
     45e:	0f 90       	pop	r0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	1f 91       	pop	r17
     466:	0f 91       	pop	r16
     468:	ff 90       	pop	r15
     46a:	ef 90       	pop	r14
     46c:	df 90       	pop	r13
     46e:	cf 90       	pop	r12
     470:	bf 90       	pop	r11
     472:	af 90       	pop	r10
     474:	9f 90       	pop	r9
     476:	8f 90       	pop	r8
     478:	08 95       	ret

0000047a <LCD_vidSendCommand_1>:
		local_u8Address=X+0x50;
		break;
	}
	/* to write to a specific address in the LCD
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_vidSendCommand_1(local_u8Address | 0x80); 
     47a:	cf 93       	push	r28
     47c:	c8 2f       	mov	r28, r24
     47e:	40 e0       	ldi	r20, 0x00	; 0
     480:	60 e0       	ldi	r22, 0x00	; 0
     482:	82 e0       	ldi	r24, 0x02	; 2
     484:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     488:	40 e0       	ldi	r20, 0x00	; 0
     48a:	61 e0       	ldi	r22, 0x01	; 1
     48c:	82 e0       	ldi	r24, 0x02	; 2
     48e:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     492:	41 e0       	ldi	r20, 0x01	; 1
     494:	62 e0       	ldi	r22, 0x02	; 2
     496:	82 e0       	ldi	r24, 0x02	; 2
     498:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     49c:	6c 2f       	mov	r22, r28
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	0e 94 7f 01 	call	0x2fe	; 0x2fe <DIO_u8SetPortValue>
     4a4:	40 e0       	ldi	r20, 0x00	; 0
     4a6:	62 e0       	ldi	r22, 0x02	; 2
     4a8:	82 e0       	ldi	r24, 0x02	; 2
     4aa:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4ae:	cf 91       	pop	r28
     4b0:	08 95       	ret

000004b2 <LCD_vidSendCommand_2>:
     4b2:	41 e0       	ldi	r20, 0x01	; 1
     4b4:	62 e0       	ldi	r22, 0x02	; 2
     4b6:	82 e0       	ldi	r24, 0x02	; 2
     4b8:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4bc:	08 95       	ret

000004be <LCD_vidWriteCharctr_1>:
     4be:	cf 93       	push	r28
     4c0:	c8 2f       	mov	r28, r24
     4c2:	41 e0       	ldi	r20, 0x01	; 1
     4c4:	60 e0       	ldi	r22, 0x00	; 0
     4c6:	82 e0       	ldi	r24, 0x02	; 2
     4c8:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4cc:	40 e0       	ldi	r20, 0x00	; 0
     4ce:	61 e0       	ldi	r22, 0x01	; 1
     4d0:	82 e0       	ldi	r24, 0x02	; 2
     4d2:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4d6:	41 e0       	ldi	r20, 0x01	; 1
     4d8:	62 e0       	ldi	r22, 0x02	; 2
     4da:	82 e0       	ldi	r24, 0x02	; 2
     4dc:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4e0:	6c 2f       	mov	r22, r28
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	0e 94 7f 01 	call	0x2fe	; 0x2fe <DIO_u8SetPortValue>
     4e8:	40 e0       	ldi	r20, 0x00	; 0
     4ea:	62 e0       	ldi	r22, 0x02	; 2
     4ec:	82 e0       	ldi	r24, 0x02	; 2
     4ee:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     4f2:	cf 91       	pop	r28
     4f4:	08 95       	ret

000004f6 <LCD_vidWriteCharctr_2>:
     4f6:	41 e0       	ldi	r20, 0x01	; 1
     4f8:	62 e0       	ldi	r22, 0x02	; 2
     4fa:	82 e0       	ldi	r24, 0x02	; 2
     4fc:	0e 94 83 00 	call	0x106	; 0x106 <DIO_u8SetPinValue>
     500:	08 95       	ret

00000502 <LCD_vidWriteString_1>:
     502:	0f 93       	push	r16
     504:	1f 93       	push	r17
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	ec 01       	movw	r28, r24
     50c:	8b 01       	movw	r16, r22
     50e:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <iteration.1804>
     512:	fe 01       	movw	r30, r28
     514:	e8 0f       	add	r30, r24
     516:	f1 1d       	adc	r31, r1
     518:	80 81       	ld	r24, Z
     51a:	88 23       	and	r24, r24
     51c:	39 f0       	breq	.+14     	; 0x52c <LCD_vidWriteString_1+0x2a>
     51e:	0e 94 5f 02 	call	0x4be	; 0x4be <LCD_vidWriteCharctr_1>
     522:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <iteration.1804>
     526:	8f 5f       	subi	r24, 0xFF	; 255
     528:	80 93 92 04 	sts	0x0492, r24	; 0x800492 <iteration.1804>
     52c:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <iteration.1804>
     530:	c8 0f       	add	r28, r24
     532:	d1 1d       	adc	r29, r1
     534:	88 81       	ld	r24, Y
     536:	81 11       	cpse	r24, r1
     538:	05 c0       	rjmp	.+10     	; 0x544 <LCD_vidWriteString_1+0x42>
     53a:	10 92 92 04 	sts	0x0492, r1	; 0x800492 <iteration.1804>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	f8 01       	movw	r30, r16
     542:	80 83       	st	Z, r24
     544:	df 91       	pop	r29
     546:	cf 91       	pop	r28
     548:	1f 91       	pop	r17
     54a:	0f 91       	pop	r16
     54c:	08 95       	ret

0000054e <LCD_VoidSendNumber>:
//
//		_delay_ms(5);
//	}
//}
void LCD_VoidSendNumber(u16 copy_u32Number)
{
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	ac 01       	movw	r20, r24
	u16 local_u32Rev=0;
     554:	c0 e0       	ldi	r28, 0x00	; 0
     556:	d0 e0       	ldi	r29, 0x00	; 0
	u16 local_u32Temp=0;
	while(copy_u32Number!=0)
     558:	30 c0       	rjmp	.+96     	; 0x5ba <LCD_VoidSendNumber+0x6c>
	{
		local_u32Rev=((local_u32Rev*10)+(copy_u32Number%10));
     55a:	ce 01       	movw	r24, r28
     55c:	88 0f       	add	r24, r24
     55e:	99 1f       	adc	r25, r25
     560:	cc 0f       	add	r28, r28
     562:	dd 1f       	adc	r29, r29
     564:	cc 0f       	add	r28, r28
     566:	dd 1f       	adc	r29, r29
     568:	cc 0f       	add	r28, r28
     56a:	dd 1f       	adc	r29, r29
     56c:	c8 0f       	add	r28, r24
     56e:	d9 1f       	adc	r29, r25
     570:	9a 01       	movw	r18, r20
     572:	ad ec       	ldi	r26, 0xCD	; 205
     574:	bc ec       	ldi	r27, 0xCC	; 204
     576:	0e 94 6d 0a 	call	0x14da	; 0x14da <__umulhisi3>
     57a:	96 95       	lsr	r25
     57c:	87 95       	ror	r24
     57e:	96 95       	lsr	r25
     580:	87 95       	ror	r24
     582:	96 95       	lsr	r25
     584:	87 95       	ror	r24
     586:	9c 01       	movw	r18, r24
     588:	22 0f       	add	r18, r18
     58a:	33 1f       	adc	r19, r19
     58c:	88 0f       	add	r24, r24
     58e:	99 1f       	adc	r25, r25
     590:	88 0f       	add	r24, r24
     592:	99 1f       	adc	r25, r25
     594:	88 0f       	add	r24, r24
     596:	99 1f       	adc	r25, r25
     598:	82 0f       	add	r24, r18
     59a:	93 1f       	adc	r25, r19
     59c:	9a 01       	movw	r18, r20
     59e:	28 1b       	sub	r18, r24
     5a0:	39 0b       	sbc	r19, r25
     5a2:	c2 0f       	add	r28, r18
     5a4:	d3 1f       	adc	r29, r19
		copy_u32Number=copy_u32Number/10;
     5a6:	9a 01       	movw	r18, r20
     5a8:	0e 94 6d 0a 	call	0x14da	; 0x14da <__umulhisi3>
     5ac:	ac 01       	movw	r20, r24
     5ae:	56 95       	lsr	r21
     5b0:	47 95       	ror	r20
     5b2:	56 95       	lsr	r21
     5b4:	47 95       	ror	r20
     5b6:	56 95       	lsr	r21
     5b8:	47 95       	ror	r20
//}
void LCD_VoidSendNumber(u16 copy_u32Number)
{
	u16 local_u32Rev=0;
	u16 local_u32Temp=0;
	while(copy_u32Number!=0)
     5ba:	41 15       	cp	r20, r1
     5bc:	51 05       	cpc	r21, r1
     5be:	69 f6       	brne	.-102    	; 0x55a <LCD_VoidSendNumber+0xc>
     5c0:	2f c0       	rjmp	.+94     	; 0x620 <LCD_VoidSendNumber+0xd2>
		local_u32Rev=((local_u32Rev*10)+(copy_u32Number%10));
		copy_u32Number=copy_u32Number/10;
	}
	while(local_u32Rev!=0)
	{
		local_u32Temp=local_u32Rev%10;
     5c2:	9e 01       	movw	r18, r28
     5c4:	ad ec       	ldi	r26, 0xCD	; 205
     5c6:	bc ec       	ldi	r27, 0xCC	; 204
     5c8:	0e 94 6d 0a 	call	0x14da	; 0x14da <__umulhisi3>
     5cc:	96 95       	lsr	r25
     5ce:	87 95       	ror	r24
     5d0:	96 95       	lsr	r25
     5d2:	87 95       	ror	r24
     5d4:	96 95       	lsr	r25
     5d6:	87 95       	ror	r24
     5d8:	9c 01       	movw	r18, r24
     5da:	22 0f       	add	r18, r18
     5dc:	33 1f       	adc	r19, r19
     5de:	88 0f       	add	r24, r24
     5e0:	99 1f       	adc	r25, r25
     5e2:	88 0f       	add	r24, r24
     5e4:	99 1f       	adc	r25, r25
     5e6:	88 0f       	add	r24, r24
     5e8:	99 1f       	adc	r25, r25
     5ea:	82 0f       	add	r24, r18
     5ec:	93 1f       	adc	r25, r19
     5ee:	9e 01       	movw	r18, r28
     5f0:	28 1b       	sub	r18, r24
     5f2:	39 0b       	sbc	r19, r25
     5f4:	c9 01       	movw	r24, r18
		LCD_vidWriteCharctr_1(local_u32Temp+48);
     5f6:	80 5d       	subi	r24, 0xD0	; 208
     5f8:	0e 94 5f 02 	call	0x4be	; 0x4be <LCD_vidWriteCharctr_1>
		vTaskDelay(1);
     5fc:	81 e0       	ldi	r24, 0x01	; 1
     5fe:	90 e0       	ldi	r25, 0x00	; 0
     600:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
		LCD_vidWriteCharctr_2();
     604:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
		local_u32Rev/=10;
     608:	9e 01       	movw	r18, r28
     60a:	ad ec       	ldi	r26, 0xCD	; 205
     60c:	bc ec       	ldi	r27, 0xCC	; 204
     60e:	0e 94 6d 0a 	call	0x14da	; 0x14da <__umulhisi3>
     612:	ec 01       	movw	r28, r24
     614:	d6 95       	lsr	r29
     616:	c7 95       	ror	r28
     618:	d6 95       	lsr	r29
     61a:	c7 95       	ror	r28
     61c:	d6 95       	lsr	r29
     61e:	c7 95       	ror	r28
	while(copy_u32Number!=0)
	{
		local_u32Rev=((local_u32Rev*10)+(copy_u32Number%10));
		copy_u32Number=copy_u32Number/10;
	}
	while(local_u32Rev!=0)
     620:	20 97       	sbiw	r28, 0x00	; 0
     622:	79 f6       	brne	.-98     	; 0x5c2 <LCD_VoidSendNumber+0x74>
		LCD_vidWriteCharctr_2();
		local_u32Rev/=10;

	}

}
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     62a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     62c:	03 96       	adiw	r24, 0x03	; 3
     62e:	92 83       	std	Z+2, r25	; 0x02
     630:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     632:	2f ef       	ldi	r18, 0xFF	; 255
     634:	3f ef       	ldi	r19, 0xFF	; 255
     636:	34 83       	std	Z+4, r19	; 0x04
     638:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     63a:	96 83       	std	Z+6, r25	; 0x06
     63c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     63e:	90 87       	std	Z+8, r25	; 0x08
     640:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     642:	10 82       	st	Z, r1
     644:	08 95       	ret

00000646 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     646:	fc 01       	movw	r30, r24
     648:	11 86       	std	Z+9, r1	; 0x09
     64a:	10 86       	std	Z+8, r1	; 0x08
     64c:	08 95       	ret

0000064e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	fc 01       	movw	r30, r24
     654:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     656:	21 81       	ldd	r18, Z+1	; 0x01
     658:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     65a:	e9 01       	movw	r28, r18
     65c:	8a 81       	ldd	r24, Y+2	; 0x02
     65e:	9b 81       	ldd	r25, Y+3	; 0x03
     660:	13 96       	adiw	r26, 0x03	; 3
     662:	9c 93       	st	X, r25
     664:	8e 93       	st	-X, r24
     666:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     668:	81 81       	ldd	r24, Z+1	; 0x01
     66a:	92 81       	ldd	r25, Z+2	; 0x02
     66c:	15 96       	adiw	r26, 0x05	; 5
     66e:	9c 93       	st	X, r25
     670:	8e 93       	st	-X, r24
     672:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     674:	8a 81       	ldd	r24, Y+2	; 0x02
     676:	9b 81       	ldd	r25, Y+3	; 0x03
     678:	ec 01       	movw	r28, r24
     67a:	7d 83       	std	Y+5, r23	; 0x05
     67c:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     67e:	e9 01       	movw	r28, r18
     680:	7b 83       	std	Y+3, r23	; 0x03
     682:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     684:	72 83       	std	Z+2, r23	; 0x02
     686:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     688:	19 96       	adiw	r26, 0x09	; 9
     68a:	fc 93       	st	X, r31
     68c:	ee 93       	st	-X, r30
     68e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     690:	80 81       	ld	r24, Z
     692:	8f 5f       	subi	r24, 0xFF	; 255
     694:	80 83       	st	Z, r24
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	08 95       	ret

0000069c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     69c:	cf 93       	push	r28
     69e:	df 93       	push	r29
     6a0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     6a2:	48 81       	ld	r20, Y
     6a4:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6a6:	4f 3f       	cpi	r20, 0xFF	; 255
     6a8:	2f ef       	ldi	r18, 0xFF	; 255
     6aa:	52 07       	cpc	r21, r18
     6ac:	31 f4       	brne	.+12     	; 0x6ba <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6ae:	dc 01       	movw	r26, r24
     6b0:	17 96       	adiw	r26, 0x07	; 7
     6b2:	ed 91       	ld	r30, X+
     6b4:	fc 91       	ld	r31, X
     6b6:	18 97       	sbiw	r26, 0x08	; 8
     6b8:	0d c0       	rjmp	.+26     	; 0x6d4 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     6ba:	fc 01       	movw	r30, r24
     6bc:	33 96       	adiw	r30, 0x03	; 3
     6be:	03 c0       	rjmp	.+6      	; 0x6c6 <vListInsert+0x2a>
     6c0:	02 80       	ldd	r0, Z+2	; 0x02
     6c2:	f3 81       	ldd	r31, Z+3	; 0x03
     6c4:	e0 2d       	mov	r30, r0
     6c6:	a2 81       	ldd	r26, Z+2	; 0x02
     6c8:	b3 81       	ldd	r27, Z+3	; 0x03
     6ca:	2d 91       	ld	r18, X+
     6cc:	3c 91       	ld	r19, X
     6ce:	42 17       	cp	r20, r18
     6d0:	53 07       	cpc	r21, r19
     6d2:	b0 f7       	brcc	.-20     	; 0x6c0 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6d4:	a2 81       	ldd	r26, Z+2	; 0x02
     6d6:	b3 81       	ldd	r27, Z+3	; 0x03
     6d8:	bb 83       	std	Y+3, r27	; 0x03
     6da:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6dc:	15 96       	adiw	r26, 0x05	; 5
     6de:	dc 93       	st	X, r29
     6e0:	ce 93       	st	-X, r28
     6e2:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     6e4:	fd 83       	std	Y+5, r31	; 0x05
     6e6:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     6e8:	d3 83       	std	Z+3, r29	; 0x03
     6ea:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ec:	99 87       	std	Y+9, r25	; 0x09
     6ee:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6f0:	fc 01       	movw	r30, r24
     6f2:	20 81       	ld	r18, Z
     6f4:	2f 5f       	subi	r18, 0xFF	; 255
     6f6:	20 83       	st	Z, r18
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     6fe:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     700:	a2 81       	ldd	r26, Z+2	; 0x02
     702:	b3 81       	ldd	r27, Z+3	; 0x03
     704:	84 81       	ldd	r24, Z+4	; 0x04
     706:	95 81       	ldd	r25, Z+5	; 0x05
     708:	15 96       	adiw	r26, 0x05	; 5
     70a:	9c 93       	st	X, r25
     70c:	8e 93       	st	-X, r24
     70e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     710:	a4 81       	ldd	r26, Z+4	; 0x04
     712:	b5 81       	ldd	r27, Z+5	; 0x05
     714:	82 81       	ldd	r24, Z+2	; 0x02
     716:	93 81       	ldd	r25, Z+3	; 0x03
     718:	13 96       	adiw	r26, 0x03	; 3
     71a:	9c 93       	st	X, r25
     71c:	8e 93       	st	-X, r24
     71e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     720:	a0 85       	ldd	r26, Z+8	; 0x08
     722:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     724:	11 96       	adiw	r26, 0x01	; 1
     726:	8d 91       	ld	r24, X+
     728:	9c 91       	ld	r25, X
     72a:	12 97       	sbiw	r26, 0x02	; 2
     72c:	e8 17       	cp	r30, r24
     72e:	f9 07       	cpc	r31, r25
     730:	31 f4       	brne	.+12     	; 0x73e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     732:	84 81       	ldd	r24, Z+4	; 0x04
     734:	95 81       	ldd	r25, Z+5	; 0x05
     736:	12 96       	adiw	r26, 0x02	; 2
     738:	9c 93       	st	X, r25
     73a:	8e 93       	st	-X, r24
     73c:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     73e:	11 86       	std	Z+9, r1	; 0x09
     740:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     742:	8c 91       	ld	r24, X
     744:	81 50       	subi	r24, 0x01	; 1
     746:	8c 93       	st	X, r24
     748:	08 95       	ret

0000074a <LCD_Init>:
}

void LCD_Init(void *pv)
{
	LCD_State STATE=LCD_STATE_INIT_COMM1;
	LCD_STRING STRING=LCD_WRITE_STRING1;
     74a:	d0 e0       	ldi	r29, 0x00	; 0
	return 0;
}

void LCD_Init(void *pv)
{
	LCD_State STATE=LCD_STATE_INIT_COMM1;
     74c:	c0 e0       	ldi	r28, 0x00	; 0
	LCD_STRING STRING=LCD_WRITE_STRING1;
	while(1)
	{
		if(flag==0)
     74e:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <flag>
     752:	81 11       	cpse	r24, r1
     754:	3a c0       	rjmp	.+116    	; 0x7ca <LCD_Init+0x80>
		{
			switch(STATE)
     756:	8c 2f       	mov	r24, r28
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	8a 30       	cpi	r24, 0x0A	; 10
     75c:	91 05       	cpc	r25, r1
     75e:	08 f0       	brcs	.+2      	; 0x762 <LCD_Init+0x18>
     760:	59 c0       	rjmp	.+178    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     762:	fc 01       	movw	r30, r24
     764:	e6 5d       	subi	r30, 0xD6	; 214
     766:	ff 4f       	sbci	r31, 0xFF	; 255
     768:	0c 94 67 0a 	jmp	0x14ce	; 0x14ce <__tablejump2__>
			{
			case LCD_STATE_INIT_COMM1:
				LCD_vidSendCommand_1(0x02);
     76c:	82 e0       	ldi	r24, 0x02	; 2
     76e:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				STATE=LCD_STATE_REST_COMM1;
     772:	c1 e0       	ldi	r28, 0x01	; 1
				break;
     774:	4f c0       	rjmp	.+158    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_REST_COMM1:
				LCD_vidSendCommand_2();
     776:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
				STATE=LCD_STATE_INIT_COMM2;
     77a:	c2 e0       	ldi	r28, 0x02	; 2
				break;
     77c:	4b c0       	rjmp	.+150    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_INIT_COMM2:
				LCD_vidSendCommand_1(0x38);
     77e:	88 e3       	ldi	r24, 0x38	; 56
     780:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				STATE=LCD_STATE_REST_COMM2;
     784:	c3 e0       	ldi	r28, 0x03	; 3
				break;
     786:	46 c0       	rjmp	.+140    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_REST_COMM2:
				LCD_vidSendCommand_2();
     788:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
				STATE=LCD_STATE_INIT_COMM3;
     78c:	c4 e0       	ldi	r28, 0x04	; 4
				break;
     78e:	42 c0       	rjmp	.+132    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_INIT_COMM3:
				LCD_vidSendCommand_1(0x0C);
     790:	8c e0       	ldi	r24, 0x0C	; 12
     792:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				STATE=LCD_STATE_REST_COMM3;
     796:	c5 e0       	ldi	r28, 0x05	; 5
				break;
     798:	3d c0       	rjmp	.+122    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_REST_COMM3:
				LCD_vidSendCommand_2();
     79a:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
				STATE=LCD_STATE_INIT_COMM4;
     79e:	c6 e0       	ldi	r28, 0x06	; 6
				break;
     7a0:	39 c0       	rjmp	.+114    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_INIT_COMM4:
				LCD_vidSendCommand_1(0x01);
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				STATE=LCD_STATE_REST_COMM4;
     7a8:	c7 e0       	ldi	r28, 0x07	; 7
				break;
     7aa:	34 c0       	rjmp	.+104    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_REST_COMM4:
				LCD_vidSendCommand_2();
     7ac:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
				STATE=LCD_STATE_INIT_COMM5;
     7b0:	c8 e0       	ldi	r28, 0x08	; 8
				break;
     7b2:	30 c0       	rjmp	.+96     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_INIT_COMM5:
				LCD_vidSendCommand_1(0x06);
     7b4:	86 e0       	ldi	r24, 0x06	; 6
     7b6:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				STATE=LCD_STATE_REST_COMM5;
     7ba:	c9 e0       	ldi	r28, 0x09	; 9
				break;
     7bc:	2b c0       	rjmp	.+86     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			case LCD_STATE_REST_COMM5:
				LCD_vidSendCommand_2();
     7be:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>

				flag=1;
     7c2:	81 e0       	ldi	r24, 0x01	; 1
     7c4:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <flag>
				break;
     7c8:	25 c0       	rjmp	.+74     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			}

		}
		/*if lcd intilized*/
		else if(flag==1)
     7ca:	81 30       	cpi	r24, 0x01	; 1
     7cc:	19 f5       	brne	.+70     	; 0x814 <__DATA_REGION_LENGTH__+0x14>


			/*if string still not equal null*/

			/*switch to which state*/
			switch(STRING)
     7ce:	dd 23       	and	r29, r29
     7d0:	19 f0       	breq	.+6      	; 0x7d8 <LCD_Init+0x8e>
     7d2:	d1 30       	cpi	r29, 0x01	; 1
     7d4:	c1 f0       	breq	.+48     	; 0x806 <__DATA_REGION_LENGTH__+0x6>
     7d6:	1e c0       	rjmp	.+60     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
			{
			/*case:still writing char*/
			case LCD_WRITE_STRING1:
				/*pass flag*/
				LCD_vidWriteString_1("password= ",&ptr_string);
     7d8:	61 ea       	ldi	r22, 0xA1	; 161
     7da:	74 e0       	ldi	r23, 0x04	; 4
     7dc:	8a e7       	ldi	r24, 0x7A	; 122
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	0e 94 81 02 	call	0x502	; 0x502 <LCD_vidWriteString_1>
				 if(ptr_string==1)
     7e4:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <ptr_string>
     7e8:	81 30       	cpi	r24, 0x01	; 1
     7ea:	89 f4       	brne	.+34     	; 0x80e <__DATA_REGION_LENGTH__+0xe>
				{

					if( xHandle != NULL )
     7ec:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <xHandle>
     7f0:	90 91 9d 04 	lds	r25, 0x049D	; 0x80049d <xHandle+0x1>
     7f4:	00 97       	sbiw	r24, 0x00	; 0
     7f6:	69 f0       	breq	.+26     	; 0x812 <__DATA_REGION_LENGTH__+0x12>
					{

						ptr_string=2;
     7f8:	22 e0       	ldi	r18, 0x02	; 2
     7fa:	20 93 a1 04 	sts	0x04A1, r18	; 0x8004a1 <ptr_string>
						vTaskDelete( xHandle );
     7fe:	0e 94 20 08 	call	0x1040	; 0x1040 <vTaskDelete>
					
					}

				}

				STRING=LCD_REST_STRING1;
     802:	d1 e0       	ldi	r29, 0x01	; 1
     804:	07 c0       	rjmp	.+14     	; 0x814 <__DATA_REGION_LENGTH__+0x14>
				break;
				/*case:display char on lcd*/
			case LCD_REST_STRING1:
				LCD_vidWriteCharctr_2();
     806:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
				STRING=LCD_WRITE_STRING1;
     80a:	d0 e0       	ldi	r29, 0x00	; 0


				break;
     80c:	03 c0       	rjmp	.+6      	; 0x814 <__DATA_REGION_LENGTH__+0x14>
					
					}

				}

				STRING=LCD_REST_STRING1;
     80e:	d1 e0       	ldi	r29, 0x01	; 1
     810:	01 c0       	rjmp	.+2      	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     812:	d1 e0       	ldi	r29, 0x01	; 1


		}


		vTaskDelay(30);
     814:	8e e1       	ldi	r24, 0x1E	; 30
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
	}
     81c:	98 cf       	rjmp	.-208    	; 0x74e <LCD_Init+0x4>

0000081e <ENTER_PASS>:
{
	LCD_char char_state=LCD_WRITE_char1;
	//	vTaskDelay(200);
	//	ptr_string=0;
	/*make state intilised*/
	LCD_STRING STRING=LCD_WRITE_STRING1;
     81e:	c0 e0       	ldi	r28, 0x00	; 0
	static u8 j=0;
	while(1)
	{

		
		if(ptr_string==2)
     820:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <ptr_string>
     824:	82 30       	cpi	r24, 0x02	; 2
     826:	09 f0       	breq	.+2      	; 0x82a <ENTER_PASS+0xc>
     828:	88 c0       	rjmp	.+272    	; 0x93a <__stack+0xdb>
		{
			//			DIO_u8SetPinValue(0,0,1);
			/*take 4 numbers to compare with password*/
			if(i<4)
     82a:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <i.2031>
     82e:	84 30       	cpi	r24, 0x04	; 4
     830:	60 f5       	brcc	.+88     	; 0x88a <__stack+0x2b>
			{
				/*get pressed key*/
				do 
				{
					KPD_u8GetKeyState(&local_u8Read);
     832:	88 e9       	ldi	r24, 0x98	; 152
     834:	94 e0       	ldi	r25, 0x04	; 4
     836:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <KPD_u8GetKeyState>
				} while (local_u8Read==0xff);
     83a:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <local_u8Read.2028>
     83e:	8f 3f       	cpi	r24, 0xFF	; 255
     840:	c1 f3       	breq	.-16     	; 0x832 <ENTER_PASS+0x14>
				
				/*check if the valid number*/
				if(local_u8Read!=0xff)
     842:	a1 f0       	breq	.+40     	; 0x86c <__stack+0xd>
					switch(char_state)
					{
						
						case LCD_WRITE_char1:
					
						LCD_vidWriteCharctr_1(local_u8Read);
     844:	0e 94 5f 02 	call	0x4be	; 0x4be <LCD_vidWriteCharctr_1>
						char_state=	LCD_REST_char1;
						vTaskDelay(1);
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
						case LCD_REST_char1:
						LCD_vidWriteCharctr_2();
     850:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
						char_state=	LCD_WRITE_char1;
					}
					/*assign to the buffer*/
					arr[i]=local_u8Read;
     854:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <i.2031>
     858:	e8 2f       	mov	r30, r24
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	ec 56       	subi	r30, 0x6C	; 108
     85e:	fb 4f       	sbci	r31, 0xFB	; 251
     860:	90 91 98 04 	lds	r25, 0x0498	; 0x800498 <local_u8Read.2028>
     864:	90 83       	st	Z, r25
					/*next element in the buffer*/
					i++;
     866:	8f 5f       	subi	r24, 0xFF	; 255
     868:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <i.2031>
				/*if not valid dont do any thing*/
				else
				{
				
				}
				if(i==4)
     86c:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <i.2031>
     870:	84 30       	cpi	r24, 0x04	; 4
     872:	09 f0       	breq	.+2      	; 0x876 <__stack+0x17>
     874:	62 c0       	rjmp	.+196    	; 0x93a <__stack+0xdb>
				{
					LCD_vidSendCommand_1(0x01);
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
					vTaskDelay(1);
     87c:	81 e0       	ldi	r24, 0x01	; 1
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
					LCD_vidSendCommand_2();
     884:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
     888:	58 c0       	rjmp	.+176    	; 0x93a <__stack+0xdb>
			}
			/*if i become more than pass size buffer */
			else
			{
				/*check for pass equal to pressed keys*/
				if(j<4)
     88a:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <j.2032>
     88e:	84 30       	cpi	r24, 0x04	; 4
     890:	88 f5       	brcc	.+98     	; 0x8f4 <__stack+0x95>
				{

					if(arr[j]!=pass[j])
     892:	28 2f       	mov	r18, r24
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	f9 01       	movw	r30, r18
     898:	ec 56       	subi	r30, 0x6C	; 108
     89a:	fb 4f       	sbci	r31, 0xFB	; 251
     89c:	40 81       	ld	r20, Z
     89e:	f9 01       	movw	r30, r18
     8a0:	e1 56       	subi	r30, 0x61	; 97
     8a2:	ff 4f       	sbci	r31, 0xFF	; 255
     8a4:	90 81       	ld	r25, Z
     8a6:	49 17       	cp	r20, r25
     8a8:	09 f1       	breq	.+66     	; 0x8ec <__stack+0x8d>
					{

						switch(STRING)
     8aa:	cc 23       	and	r28, r28
     8ac:	19 f0       	breq	.+6      	; 0x8b4 <__stack+0x55>
     8ae:	c1 30       	cpi	r28, 0x01	; 1
     8b0:	c9 f0       	breq	.+50     	; 0x8e4 <__stack+0x85>
     8b2:	43 c0       	rjmp	.+134    	; 0x93a <__stack+0xdb>
						{
						case LCD_WRITE_STRING1:
							/*pass flag*/
							
							LCD_vidWriteString_1("wrong pass",&ptr_string);
     8b4:	61 ea       	ldi	r22, 0xA1	; 161
     8b6:	74 e0       	ldi	r23, 0x04	; 4
     8b8:	85 e8       	ldi	r24, 0x85	; 133
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	0e 94 81 02 	call	0x502	; 0x502 <LCD_vidWriteString_1>
							if(ptr_string==1)
     8c0:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <ptr_string>
     8c4:	81 30       	cpi	r24, 0x01	; 1
     8c6:	51 f4       	brne	.+20     	; 0x8dc <__stack+0x7d>
							{
								LCD_vidSendCommand_1(0x01);
     8c8:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
								vTaskDelay(1);
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
								LCD_vidSendCommand_2();
     8d4:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
								i=0;
     8d8:	10 92 99 04 	sts	0x0499, r1	; 0x800499 <i.2031>
							}
							STRING=LCD_REST_STRING1;
							vTaskDelay(1);
     8dc:	81 e0       	ldi	r24, 0x01	; 1
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
						case LCD_REST_STRING1:
							LCD_vidWriteCharctr_2();
     8e4:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
							STRING=LCD_WRITE_STRING1;
     8e8:	c0 e0       	ldi	r28, 0x00	; 0


							break;
     8ea:	27 c0       	rjmp	.+78     	; 0x93a <__stack+0xdb>
						

					}
					else
					{
						j++;
     8ec:	8f 5f       	subi	r24, 0xFF	; 255
     8ee:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <j.2032>
     8f2:	23 c0       	rjmp	.+70     	; 0x93a <__stack+0xdb>
				else
				{
					
			
					
						switch(STRING)
     8f4:	cc 23       	and	r28, r28
     8f6:	19 f0       	breq	.+6      	; 0x8fe <__stack+0x9f>
     8f8:	c1 30       	cpi	r28, 0x01	; 1
     8fa:	c1 f0       	breq	.+48     	; 0x92c <__stack+0xcd>
     8fc:	1e c0       	rjmp	.+60     	; 0x93a <__stack+0xdb>
						{
						case LCD_WRITE_STRING1:
							/*pass flag*/
							
							LCD_vidWriteString_1("CORRECT",&ptr_string);
     8fe:	61 ea       	ldi	r22, 0xA1	; 161
     900:	74 e0       	ldi	r23, 0x04	; 4
     902:	80 e9       	ldi	r24, 0x90	; 144
     904:	90 e0       	ldi	r25, 0x00	; 0
     906:	0e 94 81 02 	call	0x502	; 0x502 <LCD_vidWriteString_1>
							if(ptr_string==1)
     90a:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <ptr_string>
     90e:	81 30       	cpi	r24, 0x01	; 1
     910:	89 f4       	brne	.+34     	; 0x934 <__stack+0xd5>
							{
								/*delete this task*/
								
								if( xdelete != NULL )
     912:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <xdelete>
     916:	90 91 9b 04 	lds	r25, 0x049B	; 0x80049b <xdelete+0x1>
     91a:	00 97       	sbiw	r24, 0x00	; 0
     91c:	69 f0       	breq	.+26     	; 0x938 <__stack+0xd9>
								{
									flag=2;
     91e:	22 e0       	ldi	r18, 0x02	; 2
     920:	20 93 a0 04 	sts	0x04A0, r18	; 0x8004a0 <flag>
									vTaskDelete( xdelete );
     924:	0e 94 20 08 	call	0x1040	; 0x1040 <vTaskDelete>
									
								}
							}
							STRING=LCD_REST_STRING1;
     928:	c1 e0       	ldi	r28, 0x01	; 1
     92a:	07 c0       	rjmp	.+14     	; 0x93a <__stack+0xdb>
							break;
						case LCD_REST_STRING1:
							LCD_vidWriteCharctr_2();
     92c:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
							STRING=LCD_WRITE_STRING1;
     930:	c0 e0       	ldi	r28, 0x00	; 0


							break;
     932:	03 c0       	rjmp	.+6      	; 0x93a <__stack+0xdb>
									flag=2;
									vTaskDelete( xdelete );
									
								}
							}
							STRING=LCD_REST_STRING1;
     934:	c1 e0       	ldi	r28, 0x01	; 1
     936:	01 c0       	rjmp	.+2      	; 0x93a <__stack+0xdb>
     938:	c1 e0       	ldi	r28, 0x01	; 1

		}


		//		vTaskDelayUntil(&read,Freq);
		vTaskDelay(70);
     93a:	86 e4       	ldi	r24, 0x46	; 70
     93c:	90 e0       	ldi	r25, 0x00	; 0
     93e:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
	}
     942:	6e cf       	rjmp	.-292    	; 0x820 <ENTER_PASS+0x2>

00000944 <ADC_TASK>:
void ADC_TASK(void *pv)
{
	//	portTickType Freq = 50;
	while(1)
	{
		if(flag==2)
     944:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <flag>
     948:	82 30       	cpi	r24, 0x02	; 2
     94a:	61 f5       	brne	.+88     	; 0x9a4 <ADC_TASK+0x60>
		{
			ptr_string=0;
     94c:	10 92 a1 04 	sts	0x04A1, r1	; 0x8004a1 <ptr_string>
			switch(ADC_S)
     950:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <ADC_S>
     954:	88 23       	and	r24, r24
     956:	19 f0       	breq	.+6      	; 0x95e <ADC_TASK+0x1a>
     958:	81 30       	cpi	r24, 0x01	; 1
     95a:	71 f0       	breq	.+28     	; 0x978 <ADC_TASK+0x34>
     95c:	23 c0       	rjmp	.+70     	; 0x9a4 <ADC_TASK+0x60>
			{
				case ADC_CLEAR:
				LCD_vidSendCommand_1(0x01);
     95e:	81 e0       	ldi	r24, 0x01	; 1
     960:	0e 94 3d 02 	call	0x47a	; 0x47a <LCD_vidSendCommand_1>
				vTaskDelay(1);
     964:	81 e0       	ldi	r24, 0x01	; 1
     966:	90 e0       	ldi	r25, 0x00	; 0
     968:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
				LCD_vidSendCommand_2();
     96c:	0e 94 59 02 	call	0x4b2	; 0x4b2 <LCD_vidSendCommand_2>
				ADC_S=ADC_DISPLAY;
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <ADC_S>
				break;
     976:	16 c0       	rjmp	.+44     	; 0x9a4 <ADC_TASK+0x60>
				case ADC_DISPLAY:
				LCD_vidWriteString_1("TEMP= ",&ptr_string);
     978:	61 ea       	ldi	r22, 0xA1	; 161
     97a:	74 e0       	ldi	r23, 0x04	; 4
     97c:	88 e9       	ldi	r24, 0x98	; 152
     97e:	90 e0       	ldi	r25, 0x00	; 0
     980:	0e 94 81 02 	call	0x502	; 0x502 <LCD_vidWriteString_1>
				if(ptr_string==1)
     984:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <ptr_string>
     988:	81 30       	cpi	r24, 0x01	; 1
     98a:	19 f4       	brne	.+6      	; 0x992 <ADC_TASK+0x4e>
				{
					
					flag=3;
     98c:	83 e0       	ldi	r24, 0x03	; 3
     98e:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <flag>
					
				}
				
				vTaskDelay(1);
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
				LCD_vidWriteCharctr_2();
     99a:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <LCD_vidWriteCharctr_2>
				ADC_S=ADC_DISPLAY;
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <ADC_S>
				break;
			}
		}
		if(flag==3)
     9a4:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <flag>
     9a8:	83 30       	cpi	r24, 0x03	; 3
     9aa:	41 f5       	brne	.+80     	; 0x9fc <ADC_TASK+0xb8>
		{
			ADC_u16GetDigitalValue(0,&read_temp);
     9ac:	6e e9       	ldi	r22, 0x9E	; 158
     9ae:	74 e0       	ldi	r23, 0x04	; 4
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	0e 94 69 00 	call	0xd2	; 0xd2 <ADC_u16GetDigitalValue>
			read_temp=((read_temp*5000UL)/1024);
     9b8:	20 91 9e 04 	lds	r18, 0x049E	; 0x80049e <read_temp>
     9bc:	30 91 9f 04 	lds	r19, 0x049F	; 0x80049f <read_temp+0x1>
     9c0:	a8 e8       	ldi	r26, 0x88	; 136
     9c2:	b3 e1       	ldi	r27, 0x13	; 19
     9c4:	0e 94 6d 0a 	call	0x14da	; 0x14da <__umulhisi3>
     9c8:	dc 01       	movw	r26, r24
     9ca:	cb 01       	movw	r24, r22
     9cc:	07 2e       	mov	r0, r23
     9ce:	7a e0       	ldi	r23, 0x0A	; 10
     9d0:	b6 95       	lsr	r27
     9d2:	a7 95       	ror	r26
     9d4:	97 95       	ror	r25
     9d6:	87 95       	ror	r24
     9d8:	7a 95       	dec	r23
     9da:	d1 f7       	brne	.-12     	; 0x9d0 <ADC_TASK+0x8c>
     9dc:	70 2d       	mov	r23, r0
     9de:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <read_temp+0x1>
     9e2:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <read_temp>
			
			
			LCD_VoidSendNumber(read_temp);
     9e6:	0e 94 a7 02 	call	0x54e	; 0x54e <LCD_VoidSendNumber>
			vTaskDelay(1);
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
			ADC_S=ADC_CLEAR;
     9f2:	10 92 a2 04 	sts	0x04A2, r1	; 0x8004a2 <ADC_S>
			flag=2;
     9f6:	82 e0       	ldi	r24, 0x02	; 2
     9f8:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <flag>
		}
		vTaskDelay(80);
     9fc:	80 e5       	ldi	r24, 0x50	; 80
     9fe:	90 e0       	ldi	r25, 0x00	; 0
     a00:	0e 94 bc 09 	call	0x1378	; 0x1378 <vTaskDelay>
	}
     a04:	9f cf       	rjmp	.-194    	; 0x944 <ADC_TASK>

00000a06 <main>:
void ADC_TASK(void *pv);

//void ADC_TASK(void *pv);
int main(void)
{
	DIO_Init();
     a06:	0e 94 9d 01 	call	0x33a	; 0x33a <DIO_Init>
	ADC_voidInit();
     a0a:	0e 94 53 00 	call	0xa6	; 0xa6 <ADC_voidInit>
	xTaskCreate(LCD_Init,NULL,150,NULL,3,&xHandle);
     a0e:	a1 2c       	mov	r10, r1
     a10:	b1 2c       	mov	r11, r1
     a12:	c1 2c       	mov	r12, r1
     a14:	d1 2c       	mov	r13, r1
     a16:	0f 2e       	mov	r0, r31
     a18:	fc e9       	ldi	r31, 0x9C	; 156
     a1a:	ef 2e       	mov	r14, r31
     a1c:	f4 e0       	ldi	r31, 0x04	; 4
     a1e:	ff 2e       	mov	r15, r31
     a20:	f0 2d       	mov	r31, r0
     a22:	03 e0       	ldi	r16, 0x03	; 3
     a24:	20 e0       	ldi	r18, 0x00	; 0
     a26:	30 e0       	ldi	r19, 0x00	; 0
     a28:	46 e9       	ldi	r20, 0x96	; 150
     a2a:	50 e0       	ldi	r21, 0x00	; 0
     a2c:	60 e0       	ldi	r22, 0x00	; 0
     a2e:	70 e0       	ldi	r23, 0x00	; 0
     a30:	85 ea       	ldi	r24, 0xA5	; 165
     a32:	93 e0       	ldi	r25, 0x03	; 3
     a34:	0e 94 62 07 	call	0xec4	; 0xec4 <xTaskGenericCreate>
	xTaskCreate(ADC_TASK,NULL,200,NULL,1,NULL);
     a38:	e1 2c       	mov	r14, r1
     a3a:	f1 2c       	mov	r15, r1
     a3c:	01 e0       	ldi	r16, 0x01	; 1
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	48 ec       	ldi	r20, 0xC8	; 200
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	60 e0       	ldi	r22, 0x00	; 0
     a48:	70 e0       	ldi	r23, 0x00	; 0
     a4a:	82 ea       	ldi	r24, 0xA2	; 162
     a4c:	94 e0       	ldi	r25, 0x04	; 4
     a4e:	0e 94 62 07 	call	0xec4	; 0xec4 <xTaskGenericCreate>
	xTaskCreate(ENTER_PASS,NULL,350,NULL,2,&xdelete);
     a52:	0f 2e       	mov	r0, r31
     a54:	fa e9       	ldi	r31, 0x9A	; 154
     a56:	ef 2e       	mov	r14, r31
     a58:	f4 e0       	ldi	r31, 0x04	; 4
     a5a:	ff 2e       	mov	r15, r31
     a5c:	f0 2d       	mov	r31, r0
     a5e:	02 e0       	ldi	r16, 0x02	; 2
     a60:	20 e0       	ldi	r18, 0x00	; 0
     a62:	30 e0       	ldi	r19, 0x00	; 0
     a64:	4e e5       	ldi	r20, 0x5E	; 94
     a66:	51 e0       	ldi	r21, 0x01	; 1
     a68:	60 e0       	ldi	r22, 0x00	; 0
     a6a:	70 e0       	ldi	r23, 0x00	; 0
     a6c:	8f e0       	ldi	r24, 0x0F	; 15
     a6e:	94 e0       	ldi	r25, 0x04	; 4
     a70:	0e 94 62 07 	call	0xec4	; 0xec4 <xTaskGenericCreate>
	
	vTaskStartScheduler();
     a74:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <vTaskStartScheduler>
     a78:	ff cf       	rjmp	.-2      	; 0xa78 <main+0x72>

00000a7a <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a7a:	1b bc       	out	0x2b, r1	; 43
     a7c:	8c e7       	ldi	r24, 0x7C	; 124
     a7e:	8a bd       	out	0x2a, r24	; 42
     a80:	8b e0       	ldi	r24, 0x0B	; 11
     a82:	8e bd       	out	0x2e, r24	; 46
     a84:	89 b7       	in	r24, 0x39	; 57
     a86:	80 61       	ori	r24, 0x10	; 16
     a88:	89 bf       	out	0x39, r24	; 57
     a8a:	08 95       	ret

00000a8c <pxPortInitialiseStack>:
     a8c:	31 e1       	ldi	r19, 0x11	; 17
     a8e:	fc 01       	movw	r30, r24
     a90:	30 83       	st	Z, r19
     a92:	31 97       	sbiw	r30, 0x01	; 1
     a94:	22 e2       	ldi	r18, 0x22	; 34
     a96:	20 83       	st	Z, r18
     a98:	31 97       	sbiw	r30, 0x01	; 1
     a9a:	a3 e3       	ldi	r26, 0x33	; 51
     a9c:	a0 83       	st	Z, r26
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	60 83       	st	Z, r22
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	70 83       	st	Z, r23
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	10 82       	st	Z, r1
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	60 e8       	ldi	r22, 0x80	; 128
     aae:	60 83       	st	Z, r22
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	10 82       	st	Z, r1
     ab4:	31 97       	sbiw	r30, 0x01	; 1
     ab6:	62 e0       	ldi	r22, 0x02	; 2
     ab8:	60 83       	st	Z, r22
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	63 e0       	ldi	r22, 0x03	; 3
     abe:	60 83       	st	Z, r22
     ac0:	31 97       	sbiw	r30, 0x01	; 1
     ac2:	64 e0       	ldi	r22, 0x04	; 4
     ac4:	60 83       	st	Z, r22
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	65 e0       	ldi	r22, 0x05	; 5
     aca:	60 83       	st	Z, r22
     acc:	31 97       	sbiw	r30, 0x01	; 1
     ace:	66 e0       	ldi	r22, 0x06	; 6
     ad0:	60 83       	st	Z, r22
     ad2:	31 97       	sbiw	r30, 0x01	; 1
     ad4:	67 e0       	ldi	r22, 0x07	; 7
     ad6:	60 83       	st	Z, r22
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	68 e0       	ldi	r22, 0x08	; 8
     adc:	60 83       	st	Z, r22
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	69 e0       	ldi	r22, 0x09	; 9
     ae2:	60 83       	st	Z, r22
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	60 e1       	ldi	r22, 0x10	; 16
     ae8:	60 83       	st	Z, r22
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	30 83       	st	Z, r19
     aee:	31 97       	sbiw	r30, 0x01	; 1
     af0:	32 e1       	ldi	r19, 0x12	; 18
     af2:	30 83       	st	Z, r19
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	33 e1       	ldi	r19, 0x13	; 19
     af8:	30 83       	st	Z, r19
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	34 e1       	ldi	r19, 0x14	; 20
     afe:	30 83       	st	Z, r19
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	35 e1       	ldi	r19, 0x15	; 21
     b04:	30 83       	st	Z, r19
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	36 e1       	ldi	r19, 0x16	; 22
     b0a:	30 83       	st	Z, r19
     b0c:	31 97       	sbiw	r30, 0x01	; 1
     b0e:	37 e1       	ldi	r19, 0x17	; 23
     b10:	30 83       	st	Z, r19
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	38 e1       	ldi	r19, 0x18	; 24
     b16:	30 83       	st	Z, r19
     b18:	31 97       	sbiw	r30, 0x01	; 1
     b1a:	39 e1       	ldi	r19, 0x19	; 25
     b1c:	30 83       	st	Z, r19
     b1e:	31 97       	sbiw	r30, 0x01	; 1
     b20:	30 e2       	ldi	r19, 0x20	; 32
     b22:	30 83       	st	Z, r19
     b24:	31 97       	sbiw	r30, 0x01	; 1
     b26:	31 e2       	ldi	r19, 0x21	; 33
     b28:	30 83       	st	Z, r19
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	20 83       	st	Z, r18
     b2e:	31 97       	sbiw	r30, 0x01	; 1
     b30:	23 e2       	ldi	r18, 0x23	; 35
     b32:	20 83       	st	Z, r18
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	40 83       	st	Z, r20
     b38:	31 97       	sbiw	r30, 0x01	; 1
     b3a:	50 83       	st	Z, r21
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	26 e2       	ldi	r18, 0x26	; 38
     b40:	20 83       	st	Z, r18
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	27 e2       	ldi	r18, 0x27	; 39
     b46:	20 83       	st	Z, r18
     b48:	31 97       	sbiw	r30, 0x01	; 1
     b4a:	28 e2       	ldi	r18, 0x28	; 40
     b4c:	20 83       	st	Z, r18
     b4e:	31 97       	sbiw	r30, 0x01	; 1
     b50:	29 e2       	ldi	r18, 0x29	; 41
     b52:	20 83       	st	Z, r18
     b54:	31 97       	sbiw	r30, 0x01	; 1
     b56:	20 e3       	ldi	r18, 0x30	; 48
     b58:	20 83       	st	Z, r18
     b5a:	31 97       	sbiw	r30, 0x01	; 1
     b5c:	21 e3       	ldi	r18, 0x31	; 49
     b5e:	20 83       	st	Z, r18
     b60:	86 97       	sbiw	r24, 0x26	; 38
     b62:	08 95       	ret

00000b64 <xPortStartScheduler>:
     b64:	0e 94 3d 05 	call	0xa7a	; 0xa7a <prvSetupTimerInterrupt>
     b68:	a0 91 04 05 	lds	r26, 0x0504	; 0x800504 <pxCurrentTCB>
     b6c:	b0 91 05 05 	lds	r27, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     b70:	cd 91       	ld	r28, X+
     b72:	cd bf       	out	0x3d, r28	; 61
     b74:	dd 91       	ld	r29, X+
     b76:	de bf       	out	0x3e, r29	; 62
     b78:	ff 91       	pop	r31
     b7a:	ef 91       	pop	r30
     b7c:	df 91       	pop	r29
     b7e:	cf 91       	pop	r28
     b80:	bf 91       	pop	r27
     b82:	af 91       	pop	r26
     b84:	9f 91       	pop	r25
     b86:	8f 91       	pop	r24
     b88:	7f 91       	pop	r23
     b8a:	6f 91       	pop	r22
     b8c:	5f 91       	pop	r21
     b8e:	4f 91       	pop	r20
     b90:	3f 91       	pop	r19
     b92:	2f 91       	pop	r18
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	df 90       	pop	r13
     b9e:	cf 90       	pop	r12
     ba0:	bf 90       	pop	r11
     ba2:	af 90       	pop	r10
     ba4:	9f 90       	pop	r9
     ba6:	8f 90       	pop	r8
     ba8:	7f 90       	pop	r7
     baa:	6f 90       	pop	r6
     bac:	5f 90       	pop	r5
     bae:	4f 90       	pop	r4
     bb0:	3f 90       	pop	r3
     bb2:	2f 90       	pop	r2
     bb4:	1f 90       	pop	r1
     bb6:	0f 90       	pop	r0
     bb8:	0f be       	out	0x3f, r0	; 63
     bba:	0f 90       	pop	r0
     bbc:	08 95       	ret
     bbe:	81 e0       	ldi	r24, 0x01	; 1
     bc0:	08 95       	ret

00000bc2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     bc2:	0f 92       	push	r0
     bc4:	0f b6       	in	r0, 0x3f	; 63
     bc6:	f8 94       	cli
     bc8:	0f 92       	push	r0
     bca:	1f 92       	push	r1
     bcc:	11 24       	eor	r1, r1
     bce:	2f 92       	push	r2
     bd0:	3f 92       	push	r3
     bd2:	4f 92       	push	r4
     bd4:	5f 92       	push	r5
     bd6:	6f 92       	push	r6
     bd8:	7f 92       	push	r7
     bda:	8f 92       	push	r8
     bdc:	9f 92       	push	r9
     bde:	af 92       	push	r10
     be0:	bf 92       	push	r11
     be2:	cf 92       	push	r12
     be4:	df 92       	push	r13
     be6:	ef 92       	push	r14
     be8:	ff 92       	push	r15
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	2f 93       	push	r18
     bf0:	3f 93       	push	r19
     bf2:	4f 93       	push	r20
     bf4:	5f 93       	push	r21
     bf6:	6f 93       	push	r22
     bf8:	7f 93       	push	r23
     bfa:	8f 93       	push	r24
     bfc:	9f 93       	push	r25
     bfe:	af 93       	push	r26
     c00:	bf 93       	push	r27
     c02:	cf 93       	push	r28
     c04:	df 93       	push	r29
     c06:	ef 93       	push	r30
     c08:	ff 93       	push	r31
     c0a:	a0 91 04 05 	lds	r26, 0x0504	; 0x800504 <pxCurrentTCB>
     c0e:	b0 91 05 05 	lds	r27, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     c12:	0d b6       	in	r0, 0x3d	; 61
     c14:	0d 92       	st	X+, r0
     c16:	0e b6       	in	r0, 0x3e	; 62
     c18:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c1a:	0e 94 0e 0a 	call	0x141c	; 0x141c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c1e:	a0 91 04 05 	lds	r26, 0x0504	; 0x800504 <pxCurrentTCB>
     c22:	b0 91 05 05 	lds	r27, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     c26:	cd 91       	ld	r28, X+
     c28:	cd bf       	out	0x3d, r28	; 61
     c2a:	dd 91       	ld	r29, X+
     c2c:	de bf       	out	0x3e, r29	; 62
     c2e:	ff 91       	pop	r31
     c30:	ef 91       	pop	r30
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	bf 91       	pop	r27
     c38:	af 91       	pop	r26
     c3a:	9f 91       	pop	r25
     c3c:	8f 91       	pop	r24
     c3e:	7f 91       	pop	r23
     c40:	6f 91       	pop	r22
     c42:	5f 91       	pop	r21
     c44:	4f 91       	pop	r20
     c46:	3f 91       	pop	r19
     c48:	2f 91       	pop	r18
     c4a:	1f 91       	pop	r17
     c4c:	0f 91       	pop	r16
     c4e:	ff 90       	pop	r15
     c50:	ef 90       	pop	r14
     c52:	df 90       	pop	r13
     c54:	cf 90       	pop	r12
     c56:	bf 90       	pop	r11
     c58:	af 90       	pop	r10
     c5a:	9f 90       	pop	r9
     c5c:	8f 90       	pop	r8
     c5e:	7f 90       	pop	r7
     c60:	6f 90       	pop	r6
     c62:	5f 90       	pop	r5
     c64:	4f 90       	pop	r4
     c66:	3f 90       	pop	r3
     c68:	2f 90       	pop	r2
     c6a:	1f 90       	pop	r1
     c6c:	0f 90       	pop	r0
     c6e:	0f be       	out	0x3f, r0	; 63
     c70:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c72:	08 95       	ret

00000c74 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c74:	0f 92       	push	r0
     c76:	0f b6       	in	r0, 0x3f	; 63
     c78:	f8 94       	cli
     c7a:	0f 92       	push	r0
     c7c:	1f 92       	push	r1
     c7e:	11 24       	eor	r1, r1
     c80:	2f 92       	push	r2
     c82:	3f 92       	push	r3
     c84:	4f 92       	push	r4
     c86:	5f 92       	push	r5
     c88:	6f 92       	push	r6
     c8a:	7f 92       	push	r7
     c8c:	8f 92       	push	r8
     c8e:	9f 92       	push	r9
     c90:	af 92       	push	r10
     c92:	bf 92       	push	r11
     c94:	cf 92       	push	r12
     c96:	df 92       	push	r13
     c98:	ef 92       	push	r14
     c9a:	ff 92       	push	r15
     c9c:	0f 93       	push	r16
     c9e:	1f 93       	push	r17
     ca0:	2f 93       	push	r18
     ca2:	3f 93       	push	r19
     ca4:	4f 93       	push	r20
     ca6:	5f 93       	push	r21
     ca8:	6f 93       	push	r22
     caa:	7f 93       	push	r23
     cac:	8f 93       	push	r24
     cae:	9f 93       	push	r25
     cb0:	af 93       	push	r26
     cb2:	bf 93       	push	r27
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	ef 93       	push	r30
     cba:	ff 93       	push	r31
     cbc:	a0 91 04 05 	lds	r26, 0x0504	; 0x800504 <pxCurrentTCB>
     cc0:	b0 91 05 05 	lds	r27, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     cc4:	0d b6       	in	r0, 0x3d	; 61
     cc6:	0d 92       	st	X+, r0
     cc8:	0e b6       	in	r0, 0x3e	; 62
     cca:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ccc:	0e 94 9c 08 	call	0x1138	; 0x1138 <vTaskIncrementTick>
	vTaskSwitchContext();
     cd0:	0e 94 0e 0a 	call	0x141c	; 0x141c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cd4:	a0 91 04 05 	lds	r26, 0x0504	; 0x800504 <pxCurrentTCB>
     cd8:	b0 91 05 05 	lds	r27, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     cdc:	cd 91       	ld	r28, X+
     cde:	cd bf       	out	0x3d, r28	; 61
     ce0:	dd 91       	ld	r29, X+
     ce2:	de bf       	out	0x3e, r29	; 62
     ce4:	ff 91       	pop	r31
     ce6:	ef 91       	pop	r30
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	bf 91       	pop	r27
     cee:	af 91       	pop	r26
     cf0:	9f 91       	pop	r25
     cf2:	8f 91       	pop	r24
     cf4:	7f 91       	pop	r23
     cf6:	6f 91       	pop	r22
     cf8:	5f 91       	pop	r21
     cfa:	4f 91       	pop	r20
     cfc:	3f 91       	pop	r19
     cfe:	2f 91       	pop	r18
     d00:	1f 91       	pop	r17
     d02:	0f 91       	pop	r16
     d04:	ff 90       	pop	r15
     d06:	ef 90       	pop	r14
     d08:	df 90       	pop	r13
     d0a:	cf 90       	pop	r12
     d0c:	bf 90       	pop	r11
     d0e:	af 90       	pop	r10
     d10:	9f 90       	pop	r9
     d12:	8f 90       	pop	r8
     d14:	7f 90       	pop	r7
     d16:	6f 90       	pop	r6
     d18:	5f 90       	pop	r5
     d1a:	4f 90       	pop	r4
     d1c:	3f 90       	pop	r3
     d1e:	2f 90       	pop	r2
     d20:	1f 90       	pop	r1
     d22:	0f 90       	pop	r0
     d24:	0f be       	out	0x3f, r0	; 63
     d26:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d28:	08 95       	ret

00000d2a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void __vector_7( void ) __attribute__ ( ( signal, naked ) );
	void __vector_7( void )
	{
		vPortYieldFromTick();
     d2a:	0e 94 3a 06 	call	0xc74	; 0xc74 <vPortYieldFromTick>
		asm volatile ( "reti" );
     d2e:	18 95       	reti

00000d30 <prvDeleteTCB>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
     d34:	ec 01       	movw	r28, r24
     d36:	8f 89       	ldd	r24, Y+23	; 0x17
     d38:	98 8d       	ldd	r25, Y+24	; 0x18
     d3a:	0e 94 cf 01 	call	0x39e	; 0x39e <vPortFree>
     d3e:	ce 01       	movw	r24, r28
     d40:	0e 94 cf 01 	call	0x39e	; 0x39e <vPortFree>
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	08 95       	ret

00000d4a <prvAllocateTCBAndStack>:
     d4a:	ef 92       	push	r14
     d4c:	ff 92       	push	r15
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	7c 01       	movw	r14, r24
     d58:	eb 01       	movw	r28, r22
     d5a:	81 e2       	ldi	r24, 0x21	; 33
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	0e 94 a9 01 	call	0x352	; 0x352 <pvPortMalloc>
     d62:	8c 01       	movw	r16, r24
     d64:	89 2b       	or	r24, r25
     d66:	b9 f0       	breq	.+46     	; 0xd96 <prvAllocateTCBAndStack+0x4c>
     d68:	20 97       	sbiw	r28, 0x00	; 0
     d6a:	21 f4       	brne	.+8      	; 0xd74 <prvAllocateTCBAndStack+0x2a>
     d6c:	c7 01       	movw	r24, r14
     d6e:	0e 94 a9 01 	call	0x352	; 0x352 <pvPortMalloc>
     d72:	01 c0       	rjmp	.+2      	; 0xd76 <prvAllocateTCBAndStack+0x2c>
     d74:	ce 01       	movw	r24, r28
     d76:	f8 01       	movw	r30, r16
     d78:	90 8f       	std	Z+24, r25	; 0x18
     d7a:	87 8b       	std	Z+23, r24	; 0x17
     d7c:	00 97       	sbiw	r24, 0x00	; 0
     d7e:	31 f4       	brne	.+12     	; 0xd8c <prvAllocateTCBAndStack+0x42>
     d80:	c8 01       	movw	r24, r16
     d82:	0e 94 cf 01 	call	0x39e	; 0x39e <vPortFree>
     d86:	00 e0       	ldi	r16, 0x00	; 0
     d88:	10 e0       	ldi	r17, 0x00	; 0
     d8a:	05 c0       	rjmp	.+10     	; 0xd96 <prvAllocateTCBAndStack+0x4c>
     d8c:	a7 01       	movw	r20, r14
     d8e:	65 ea       	ldi	r22, 0xA5	; 165
     d90:	70 e0       	ldi	r23, 0x00	; 0
     d92:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <memset>
     d96:	c8 01       	movw	r24, r16
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	ff 90       	pop	r15
     da2:	ef 90       	pop	r14
     da4:	08 95       	ret

00000da6 <prvInitialiseTCBVariables>:
     da6:	1f 93       	push	r17
     da8:	cf 93       	push	r28
     daa:	df 93       	push	r29
     dac:	ec 01       	movw	r28, r24
     dae:	14 2f       	mov	r17, r20
     db0:	48 e0       	ldi	r20, 0x08	; 8
     db2:	50 e0       	ldi	r21, 0x00	; 0
     db4:	49 96       	adiw	r24, 0x19	; 25
     db6:	0e 94 83 0a 	call	0x1506	; 0x1506 <strncpy>
     dba:	18 a2       	std	Y+32, r1	; 0x20
     dbc:	15 30       	cpi	r17, 0x05	; 5
     dbe:	08 f0       	brcs	.+2      	; 0xdc2 <prvInitialiseTCBVariables+0x1c>
     dc0:	14 e0       	ldi	r17, 0x04	; 4
     dc2:	1e 8b       	std	Y+22, r17	; 0x16
     dc4:	ce 01       	movw	r24, r28
     dc6:	02 96       	adiw	r24, 0x02	; 2
     dc8:	0e 94 23 03 	call	0x646	; 0x646 <vListInitialiseItem>
     dcc:	ce 01       	movw	r24, r28
     dce:	0c 96       	adiw	r24, 0x0c	; 12
     dd0:	0e 94 23 03 	call	0x646	; 0x646 <vListInitialiseItem>
     dd4:	d9 87       	std	Y+9, r29	; 0x09
     dd6:	c8 87       	std	Y+8, r28	; 0x08
     dd8:	85 e0       	ldi	r24, 0x05	; 5
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	81 1b       	sub	r24, r17
     dde:	91 09       	sbc	r25, r1
     de0:	9d 87       	std	Y+13, r25	; 0x0d
     de2:	8c 87       	std	Y+12, r24	; 0x0c
     de4:	db 8b       	std	Y+19, r29	; 0x13
     de6:	ca 8b       	std	Y+18, r28	; 0x12
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	1f 91       	pop	r17
     dee:	08 95       	ret

00000df0 <prvInitialiseTaskLists>:
     df0:	cf 93       	push	r28
     df2:	c0 e0       	ldi	r28, 0x00	; 0
     df4:	10 c0       	rjmp	.+32     	; 0xe16 <prvInitialiseTaskLists+0x26>
     df6:	8c 2f       	mov	r24, r28
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	9c 01       	movw	r18, r24
     dfc:	22 0f       	add	r18, r18
     dfe:	33 1f       	adc	r19, r19
     e00:	22 0f       	add	r18, r18
     e02:	33 1f       	adc	r19, r19
     e04:	22 0f       	add	r18, r18
     e06:	33 1f       	adc	r19, r19
     e08:	82 0f       	add	r24, r18
     e0a:	93 1f       	adc	r25, r19
     e0c:	89 52       	subi	r24, 0x29	; 41
     e0e:	9b 4f       	sbci	r25, 0xFB	; 251
     e10:	0e 94 15 03 	call	0x62a	; 0x62a <vListInitialise>
     e14:	cf 5f       	subi	r28, 0xFF	; 255
     e16:	c5 30       	cpi	r28, 0x05	; 5
     e18:	70 f3       	brcs	.-36     	; 0xdf6 <prvInitialiseTaskLists+0x6>
     e1a:	8e ec       	ldi	r24, 0xCE	; 206
     e1c:	94 e0       	ldi	r25, 0x04	; 4
     e1e:	0e 94 15 03 	call	0x62a	; 0x62a <vListInitialise>
     e22:	85 ec       	ldi	r24, 0xC5	; 197
     e24:	94 e0       	ldi	r25, 0x04	; 4
     e26:	0e 94 15 03 	call	0x62a	; 0x62a <vListInitialise>
     e2a:	88 eb       	ldi	r24, 0xB8	; 184
     e2c:	94 e0       	ldi	r25, 0x04	; 4
     e2e:	0e 94 15 03 	call	0x62a	; 0x62a <vListInitialise>
     e32:	8f ea       	ldi	r24, 0xAF	; 175
     e34:	94 e0       	ldi	r25, 0x04	; 4
     e36:	0e 94 15 03 	call	0x62a	; 0x62a <vListInitialise>
     e3a:	8e ec       	ldi	r24, 0xCE	; 206
     e3c:	94 e0       	ldi	r25, 0x04	; 4
     e3e:	90 93 c4 04 	sts	0x04C4, r25	; 0x8004c4 <pxDelayedTaskList+0x1>
     e42:	80 93 c3 04 	sts	0x04C3, r24	; 0x8004c3 <pxDelayedTaskList>
     e46:	85 ec       	ldi	r24, 0xC5	; 197
     e48:	94 e0       	ldi	r25, 0x04	; 4
     e4a:	90 93 c2 04 	sts	0x04C2, r25	; 0x8004c2 <pxOverflowDelayedTaskList+0x1>
     e4e:	80 93 c1 04 	sts	0x04C1, r24	; 0x8004c1 <pxOverflowDelayedTaskList>
     e52:	cf 91       	pop	r28
     e54:	08 95       	ret

00000e56 <prvAddCurrentTaskToDelayedList>:
     e56:	cf 93       	push	r28
     e58:	df 93       	push	r29
     e5a:	ec 01       	movw	r28, r24
     e5c:	e0 91 04 05 	lds	r30, 0x0504	; 0x800504 <pxCurrentTCB>
     e60:	f0 91 05 05 	lds	r31, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     e64:	93 83       	std	Z+3, r25	; 0x03
     e66:	82 83       	std	Z+2, r24	; 0x02
     e68:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <xTickCount>
     e6c:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <xTickCount+0x1>
     e70:	c8 17       	cp	r28, r24
     e72:	d9 07       	cpc	r29, r25
     e74:	68 f4       	brcc	.+26     	; 0xe90 <prvAddCurrentTaskToDelayedList+0x3a>
     e76:	60 91 04 05 	lds	r22, 0x0504	; 0x800504 <pxCurrentTCB>
     e7a:	70 91 05 05 	lds	r23, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     e7e:	80 91 c1 04 	lds	r24, 0x04C1	; 0x8004c1 <pxOverflowDelayedTaskList>
     e82:	90 91 c2 04 	lds	r25, 0x04C2	; 0x8004c2 <pxOverflowDelayedTaskList+0x1>
     e86:	6e 5f       	subi	r22, 0xFE	; 254
     e88:	7f 4f       	sbci	r23, 0xFF	; 255
     e8a:	0e 94 4e 03 	call	0x69c	; 0x69c <vListInsert>
     e8e:	17 c0       	rjmp	.+46     	; 0xebe <prvAddCurrentTaskToDelayedList+0x68>
     e90:	60 91 04 05 	lds	r22, 0x0504	; 0x800504 <pxCurrentTCB>
     e94:	70 91 05 05 	lds	r23, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     e98:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
     e9c:	90 91 c4 04 	lds	r25, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
     ea0:	6e 5f       	subi	r22, 0xFE	; 254
     ea2:	7f 4f       	sbci	r23, 0xFF	; 255
     ea4:	0e 94 4e 03 	call	0x69c	; 0x69c <vListInsert>
     ea8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     eac:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     eb0:	c8 17       	cp	r28, r24
     eb2:	d9 07       	cpc	r29, r25
     eb4:	20 f4       	brcc	.+8      	; 0xebe <prvAddCurrentTaskToDelayedList+0x68>
     eb6:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     eba:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	08 95       	ret

00000ec4 <xTaskGenericCreate>:
     ec4:	2f 92       	push	r2
     ec6:	3f 92       	push	r3
     ec8:	4f 92       	push	r4
     eca:	5f 92       	push	r5
     ecc:	7f 92       	push	r7
     ece:	8f 92       	push	r8
     ed0:	9f 92       	push	r9
     ed2:	af 92       	push	r10
     ed4:	bf 92       	push	r11
     ed6:	cf 92       	push	r12
     ed8:	df 92       	push	r13
     eda:	ef 92       	push	r14
     edc:	ff 92       	push	r15
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <xTaskGenericCreate+0x24>
     ee8:	00 d0       	rcall	.+0      	; 0xeea <xTaskGenericCreate+0x26>
     eea:	cd b7       	in	r28, 0x3d	; 61
     eec:	de b7       	in	r29, 0x3e	; 62
     eee:	9a 83       	std	Y+2, r25	; 0x02
     ef0:	89 83       	std	Y+1, r24	; 0x01
     ef2:	4b 01       	movw	r8, r22
     ef4:	5c 83       	std	Y+4, r21	; 0x04
     ef6:	4b 83       	std	Y+3, r20	; 0x03
     ef8:	19 01       	movw	r2, r18
     efa:	70 2e       	mov	r7, r16
     efc:	b6 01       	movw	r22, r12
     efe:	25 01       	movw	r4, r10
     f00:	ca 01       	movw	r24, r20
     f02:	0e 94 a5 06 	call	0xd4a	; 0xd4a <prvAllocateTCBAndStack>
     f06:	5c 01       	movw	r10, r24
     f08:	00 97       	sbiw	r24, 0x00	; 0
     f0a:	09 f4       	brne	.+2      	; 0xf0e <xTaskGenericCreate+0x4a>
     f0c:	70 c0       	rjmp	.+224    	; 0xfee <xTaskGenericCreate+0x12a>
     f0e:	fc 01       	movw	r30, r24
     f10:	c7 88       	ldd	r12, Z+23	; 0x17
     f12:	d0 8c       	ldd	r13, Z+24	; 0x18
     f14:	8b 81       	ldd	r24, Y+3	; 0x03
     f16:	9c 81       	ldd	r25, Y+4	; 0x04
     f18:	01 97       	sbiw	r24, 0x01	; 1
     f1a:	c8 0e       	add	r12, r24
     f1c:	d9 1e       	adc	r13, r25
     f1e:	0b 81       	ldd	r16, Y+3	; 0x03
     f20:	1c 81       	ldd	r17, Y+4	; 0x04
     f22:	92 01       	movw	r18, r4
     f24:	47 2d       	mov	r20, r7
     f26:	b4 01       	movw	r22, r8
     f28:	c5 01       	movw	r24, r10
     f2a:	0e 94 d3 06 	call	0xda6	; 0xda6 <prvInitialiseTCBVariables>
     f2e:	a1 01       	movw	r20, r2
     f30:	69 81       	ldd	r22, Y+1	; 0x01
     f32:	7a 81       	ldd	r23, Y+2	; 0x02
     f34:	c6 01       	movw	r24, r12
     f36:	0e 94 46 05 	call	0xa8c	; 0xa8c <pxPortInitialiseStack>
     f3a:	f5 01       	movw	r30, r10
     f3c:	91 83       	std	Z+1, r25	; 0x01
     f3e:	80 83       	st	Z, r24
     f40:	e1 14       	cp	r14, r1
     f42:	f1 04       	cpc	r15, r1
     f44:	19 f0       	breq	.+6      	; 0xf4c <xTaskGenericCreate+0x88>
     f46:	f7 01       	movw	r30, r14
     f48:	b1 82       	std	Z+1, r11	; 0x01
     f4a:	a0 82       	st	Z, r10
     f4c:	0f b6       	in	r0, 0x3f	; 63
     f4e:	f8 94       	cli
     f50:	0f 92       	push	r0
     f52:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <uxCurrentNumberOfTasks>
     f56:	8f 5f       	subi	r24, 0xFF	; 255
     f58:	80 93 ad 04 	sts	0x04AD, r24	; 0x8004ad <uxCurrentNumberOfTasks>
     f5c:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <pxCurrentTCB>
     f60:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     f64:	89 2b       	or	r24, r25
     f66:	59 f4       	brne	.+22     	; 0xf7e <xTaskGenericCreate+0xba>
     f68:	b0 92 05 05 	sts	0x0505, r11	; 0x800505 <pxCurrentTCB+0x1>
     f6c:	a0 92 04 05 	sts	0x0504, r10	; 0x800504 <pxCurrentTCB>
     f70:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <uxCurrentNumberOfTasks>
     f74:	81 30       	cpi	r24, 0x01	; 1
     f76:	91 f4       	brne	.+36     	; 0xf9c <xTaskGenericCreate+0xd8>
     f78:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <prvInitialiseTaskLists>
     f7c:	0f c0       	rjmp	.+30     	; 0xf9c <xTaskGenericCreate+0xd8>
     f7e:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <xSchedulerRunning>
     f82:	81 11       	cpse	r24, r1
     f84:	0b c0       	rjmp	.+22     	; 0xf9c <xTaskGenericCreate+0xd8>
     f86:	e0 91 04 05 	lds	r30, 0x0504	; 0x800504 <pxCurrentTCB>
     f8a:	f0 91 05 05 	lds	r31, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
     f8e:	86 89       	ldd	r24, Z+22	; 0x16
     f90:	78 16       	cp	r7, r24
     f92:	20 f0       	brcs	.+8      	; 0xf9c <xTaskGenericCreate+0xd8>
     f94:	b0 92 05 05 	sts	0x0505, r11	; 0x800505 <pxCurrentTCB+0x1>
     f98:	a0 92 04 05 	sts	0x0504, r10	; 0x800504 <pxCurrentTCB>
     f9c:	f5 01       	movw	r30, r10
     f9e:	86 89       	ldd	r24, Z+22	; 0x16
     fa0:	90 91 aa 04 	lds	r25, 0x04AA	; 0x8004aa <uxTopUsedPriority>
     fa4:	98 17       	cp	r25, r24
     fa6:	10 f4       	brcc	.+4      	; 0xfac <xTaskGenericCreate+0xe8>
     fa8:	80 93 aa 04 	sts	0x04AA, r24	; 0x8004aa <uxTopUsedPriority>
     fac:	90 91 a3 04 	lds	r25, 0x04A3	; 0x8004a3 <uxTaskNumber>
     fb0:	9f 5f       	subi	r25, 0xFF	; 255
     fb2:	90 93 a3 04 	sts	0x04A3, r25	; 0x8004a3 <uxTaskNumber>
     fb6:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
     fba:	98 17       	cp	r25, r24
     fbc:	10 f4       	brcc	.+4      	; 0xfc2 <xTaskGenericCreate+0xfe>
     fbe:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxTopReadyPriority>
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	b5 01       	movw	r22, r10
     fc6:	6e 5f       	subi	r22, 0xFE	; 254
     fc8:	7f 4f       	sbci	r23, 0xFF	; 255
     fca:	9c 01       	movw	r18, r24
     fcc:	22 0f       	add	r18, r18
     fce:	33 1f       	adc	r19, r19
     fd0:	22 0f       	add	r18, r18
     fd2:	33 1f       	adc	r19, r19
     fd4:	22 0f       	add	r18, r18
     fd6:	33 1f       	adc	r19, r19
     fd8:	82 0f       	add	r24, r18
     fda:	93 1f       	adc	r25, r19
     fdc:	89 52       	subi	r24, 0x29	; 41
     fde:	9b 4f       	sbci	r25, 0xFB	; 251
     fe0:	0e 94 27 03 	call	0x64e	; 0x64e <vListInsertEnd>
     fe4:	0f 90       	pop	r0
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	f1 e0       	ldi	r31, 0x01	; 1
     fea:	f9 83       	std	Y+1, r31	; 0x01
     fec:	02 c0       	rjmp	.+4      	; 0xff2 <xTaskGenericCreate+0x12e>
     fee:	8f ef       	ldi	r24, 0xFF	; 255
     ff0:	89 83       	std	Y+1, r24	; 0x01
     ff2:	e9 81       	ldd	r30, Y+1	; 0x01
     ff4:	e1 30       	cpi	r30, 0x01	; 1
     ff6:	69 f4       	brne	.+26     	; 0x1012 <xTaskGenericCreate+0x14e>
     ff8:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <xSchedulerRunning>
     ffc:	88 23       	and	r24, r24
     ffe:	49 f0       	breq	.+18     	; 0x1012 <xTaskGenericCreate+0x14e>
    1000:	e0 91 04 05 	lds	r30, 0x0504	; 0x800504 <pxCurrentTCB>
    1004:	f0 91 05 05 	lds	r31, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
    1008:	86 89       	ldd	r24, Z+22	; 0x16
    100a:	87 15       	cp	r24, r7
    100c:	10 f4       	brcc	.+4      	; 0x1012 <xTaskGenericCreate+0x14e>
    100e:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <vPortYield>
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	0f 90       	pop	r0
    1016:	0f 90       	pop	r0
    1018:	0f 90       	pop	r0
    101a:	0f 90       	pop	r0
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	ff 90       	pop	r15
    1026:	ef 90       	pop	r14
    1028:	df 90       	pop	r13
    102a:	cf 90       	pop	r12
    102c:	bf 90       	pop	r11
    102e:	af 90       	pop	r10
    1030:	9f 90       	pop	r9
    1032:	8f 90       	pop	r8
    1034:	7f 90       	pop	r7
    1036:	5f 90       	pop	r5
    1038:	4f 90       	pop	r4
    103a:	3f 90       	pop	r3
    103c:	2f 90       	pop	r2
    103e:	08 95       	ret

00001040 <vTaskDelete>:
    1040:	ef 92       	push	r14
    1042:	ff 92       	push	r15
    1044:	0f 93       	push	r16
    1046:	1f 93       	push	r17
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	ec 01       	movw	r28, r24
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    1054:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <pxCurrentTCB>
    1058:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
    105c:	8c 17       	cp	r24, r28
    105e:	9d 07       	cpc	r25, r29
    1060:	11 f4       	brne	.+4      	; 0x1066 <vTaskDelete+0x26>
    1062:	c0 e0       	ldi	r28, 0x00	; 0
    1064:	d0 e0       	ldi	r29, 0x00	; 0
    1066:	20 97       	sbiw	r28, 0x00	; 0
    1068:	29 f4       	brne	.+10     	; 0x1074 <vTaskDelete+0x34>
    106a:	00 91 04 05 	lds	r16, 0x0504	; 0x800504 <pxCurrentTCB>
    106e:	10 91 05 05 	lds	r17, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
    1072:	01 c0       	rjmp	.+2      	; 0x1076 <vTaskDelete+0x36>
    1074:	8e 01       	movw	r16, r28
    1076:	78 01       	movw	r14, r16
    1078:	82 e0       	ldi	r24, 0x02	; 2
    107a:	e8 0e       	add	r14, r24
    107c:	f1 1c       	adc	r15, r1
    107e:	c7 01       	movw	r24, r14
    1080:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    1084:	f8 01       	movw	r30, r16
    1086:	84 89       	ldd	r24, Z+20	; 0x14
    1088:	95 89       	ldd	r25, Z+21	; 0x15
    108a:	89 2b       	or	r24, r25
    108c:	21 f0       	breq	.+8      	; 0x1096 <vTaskDelete+0x56>
    108e:	c8 01       	movw	r24, r16
    1090:	0c 96       	adiw	r24, 0x0c	; 12
    1092:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    1096:	b7 01       	movw	r22, r14
    1098:	8f ea       	ldi	r24, 0xAF	; 175
    109a:	94 e0       	ldi	r25, 0x04	; 4
    109c:	0e 94 27 03 	call	0x64e	; 0x64e <vListInsertEnd>
    10a0:	80 91 ae 04 	lds	r24, 0x04AE	; 0x8004ae <uxTasksDeleted>
    10a4:	8f 5f       	subi	r24, 0xFF	; 255
    10a6:	80 93 ae 04 	sts	0x04AE, r24	; 0x8004ae <uxTasksDeleted>
    10aa:	80 91 a3 04 	lds	r24, 0x04A3	; 0x8004a3 <uxTaskNumber>
    10ae:	8f 5f       	subi	r24, 0xFF	; 255
    10b0:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <uxTaskNumber>
    10b4:	0f 90       	pop	r0
    10b6:	0f be       	out	0x3f, r0	; 63
    10b8:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <xSchedulerRunning>
    10bc:	88 23       	and	r24, r24
    10be:	21 f0       	breq	.+8      	; 0x10c8 <vTaskDelete+0x88>
    10c0:	cd 2b       	or	r28, r29
    10c2:	11 f4       	brne	.+4      	; 0x10c8 <vTaskDelete+0x88>
    10c4:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <vPortYield>
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	1f 91       	pop	r17
    10ce:	0f 91       	pop	r16
    10d0:	ff 90       	pop	r15
    10d2:	ef 90       	pop	r14
    10d4:	08 95       	ret

000010d6 <vTaskStartScheduler>:
    10d6:	af 92       	push	r10
    10d8:	bf 92       	push	r11
    10da:	cf 92       	push	r12
    10dc:	df 92       	push	r13
    10de:	ef 92       	push	r14
    10e0:	ff 92       	push	r15
    10e2:	0f 93       	push	r16
    10e4:	a1 2c       	mov	r10, r1
    10e6:	b1 2c       	mov	r11, r1
    10e8:	c1 2c       	mov	r12, r1
    10ea:	d1 2c       	mov	r13, r1
    10ec:	e1 2c       	mov	r14, r1
    10ee:	f1 2c       	mov	r15, r1
    10f0:	00 e0       	ldi	r16, 0x00	; 0
    10f2:	20 e0       	ldi	r18, 0x00	; 0
    10f4:	30 e0       	ldi	r19, 0x00	; 0
    10f6:	45 e5       	ldi	r20, 0x55	; 85
    10f8:	50 e0       	ldi	r21, 0x00	; 0
    10fa:	63 ea       	ldi	r22, 0xA3	; 163
    10fc:	70 e0       	ldi	r23, 0x00	; 0
    10fe:	8b e0       	ldi	r24, 0x0B	; 11
    1100:	9a e0       	ldi	r25, 0x0A	; 10
    1102:	0e 94 62 07 	call	0xec4	; 0xec4 <xTaskGenericCreate>
    1106:	81 30       	cpi	r24, 0x01	; 1
    1108:	49 f4       	brne	.+18     	; 0x111c <vTaskStartScheduler+0x46>
    110a:	f8 94       	cli
    110c:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <xSchedulerRunning>
    1110:	10 92 ac 04 	sts	0x04AC, r1	; 0x8004ac <xTickCount+0x1>
    1114:	10 92 ab 04 	sts	0x04AB, r1	; 0x8004ab <xTickCount>
    1118:	0e 94 b2 05 	call	0xb64	; 0xb64 <xPortStartScheduler>
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	bf 90       	pop	r11
    1128:	af 90       	pop	r10
    112a:	08 95       	ret

0000112c <vTaskSuspendAll>:
    112c:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxSchedulerSuspended>
    1130:	8f 5f       	subi	r24, 0xFF	; 255
    1132:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <uxSchedulerSuspended>
    1136:	08 95       	ret

00001138 <vTaskIncrementTick>:
    1138:	0f 93       	push	r16
    113a:	1f 93       	push	r17
    113c:	cf 93       	push	r28
    113e:	df 93       	push	r29
    1140:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxSchedulerSuspended>
    1144:	81 11       	cpse	r24, r1
    1146:	98 c0       	rjmp	.+304    	; 0x1278 <vTaskIncrementTick+0x140>
    1148:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <xTickCount>
    114c:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <xTickCount+0x1>
    1150:	01 96       	adiw	r24, 0x01	; 1
    1152:	90 93 ac 04 	sts	0x04AC, r25	; 0x8004ac <xTickCount+0x1>
    1156:	80 93 ab 04 	sts	0x04AB, r24	; 0x8004ab <xTickCount>
    115a:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <xTickCount>
    115e:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <xTickCount+0x1>
    1162:	89 2b       	or	r24, r25
    1164:	99 f5       	brne	.+102    	; 0x11cc <vTaskIncrementTick+0x94>
    1166:	80 91 c3 04 	lds	r24, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
    116a:	90 91 c4 04 	lds	r25, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
    116e:	20 91 c1 04 	lds	r18, 0x04C1	; 0x8004c1 <pxOverflowDelayedTaskList>
    1172:	30 91 c2 04 	lds	r19, 0x04C2	; 0x8004c2 <pxOverflowDelayedTaskList+0x1>
    1176:	30 93 c4 04 	sts	0x04C4, r19	; 0x8004c4 <pxDelayedTaskList+0x1>
    117a:	20 93 c3 04 	sts	0x04C3, r18	; 0x8004c3 <pxDelayedTaskList>
    117e:	90 93 c2 04 	sts	0x04C2, r25	; 0x8004c2 <pxOverflowDelayedTaskList+0x1>
    1182:	80 93 c1 04 	sts	0x04C1, r24	; 0x8004c1 <pxOverflowDelayedTaskList>
    1186:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <xNumOfOverflows>
    118a:	8f 5f       	subi	r24, 0xFF	; 255
    118c:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <xNumOfOverflows>
    1190:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
    1194:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
    1198:	80 81       	ld	r24, Z
    119a:	81 11       	cpse	r24, r1
    119c:	07 c0       	rjmp	.+14     	; 0x11ac <vTaskIncrementTick+0x74>
    119e:	8f ef       	ldi	r24, 0xFF	; 255
    11a0:	9f ef       	ldi	r25, 0xFF	; 255
    11a2:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    11a6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    11aa:	10 c0       	rjmp	.+32     	; 0x11cc <vTaskIncrementTick+0x94>
    11ac:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
    11b0:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
    11b4:	05 80       	ldd	r0, Z+5	; 0x05
    11b6:	f6 81       	ldd	r31, Z+6	; 0x06
    11b8:	e0 2d       	mov	r30, r0
    11ba:	06 80       	ldd	r0, Z+6	; 0x06
    11bc:	f7 81       	ldd	r31, Z+7	; 0x07
    11be:	e0 2d       	mov	r30, r0
    11c0:	82 81       	ldd	r24, Z+2	; 0x02
    11c2:	93 81       	ldd	r25, Z+3	; 0x03
    11c4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    11c8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    11cc:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <xTickCount>
    11d0:	30 91 ac 04 	lds	r19, 0x04AC	; 0x8004ac <xTickCount+0x1>
    11d4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    11d8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    11dc:	28 17       	cp	r18, r24
    11de:	39 07       	cpc	r19, r25
    11e0:	08 f4       	brcc	.+2      	; 0x11e4 <vTaskIncrementTick+0xac>
    11e2:	4f c0       	rjmp	.+158    	; 0x1282 <vTaskIncrementTick+0x14a>
    11e4:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
    11e8:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
    11ec:	80 81       	ld	r24, Z
    11ee:	81 11       	cpse	r24, r1
    11f0:	07 c0       	rjmp	.+14     	; 0x1200 <vTaskIncrementTick+0xc8>
    11f2:	8f ef       	ldi	r24, 0xFF	; 255
    11f4:	9f ef       	ldi	r25, 0xFF	; 255
    11f6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    11fa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    11fe:	41 c0       	rjmp	.+130    	; 0x1282 <vTaskIncrementTick+0x14a>
    1200:	e0 91 c3 04 	lds	r30, 0x04C3	; 0x8004c3 <pxDelayedTaskList>
    1204:	f0 91 c4 04 	lds	r31, 0x04C4	; 0x8004c4 <pxDelayedTaskList+0x1>
    1208:	05 80       	ldd	r0, Z+5	; 0x05
    120a:	f6 81       	ldd	r31, Z+6	; 0x06
    120c:	e0 2d       	mov	r30, r0
    120e:	c6 81       	ldd	r28, Z+6	; 0x06
    1210:	d7 81       	ldd	r29, Z+7	; 0x07
    1212:	8a 81       	ldd	r24, Y+2	; 0x02
    1214:	9b 81       	ldd	r25, Y+3	; 0x03
    1216:	20 91 ab 04 	lds	r18, 0x04AB	; 0x8004ab <xTickCount>
    121a:	30 91 ac 04 	lds	r19, 0x04AC	; 0x8004ac <xTickCount+0x1>
    121e:	28 17       	cp	r18, r24
    1220:	39 07       	cpc	r19, r25
    1222:	28 f4       	brcc	.+10     	; 0x122e <vTaskIncrementTick+0xf6>
    1224:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1228:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    122c:	2a c0       	rjmp	.+84     	; 0x1282 <vTaskIncrementTick+0x14a>
    122e:	8e 01       	movw	r16, r28
    1230:	0e 5f       	subi	r16, 0xFE	; 254
    1232:	1f 4f       	sbci	r17, 0xFF	; 255
    1234:	c8 01       	movw	r24, r16
    1236:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    123a:	8c 89       	ldd	r24, Y+20	; 0x14
    123c:	9d 89       	ldd	r25, Y+21	; 0x15
    123e:	89 2b       	or	r24, r25
    1240:	21 f0       	breq	.+8      	; 0x124a <vTaskIncrementTick+0x112>
    1242:	ce 01       	movw	r24, r28
    1244:	0c 96       	adiw	r24, 0x0c	; 12
    1246:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    124a:	8e 89       	ldd	r24, Y+22	; 0x16
    124c:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
    1250:	98 17       	cp	r25, r24
    1252:	10 f4       	brcc	.+4      	; 0x1258 <vTaskIncrementTick+0x120>
    1254:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxTopReadyPriority>
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	9c 01       	movw	r18, r24
    125c:	22 0f       	add	r18, r18
    125e:	33 1f       	adc	r19, r19
    1260:	22 0f       	add	r18, r18
    1262:	33 1f       	adc	r19, r19
    1264:	22 0f       	add	r18, r18
    1266:	33 1f       	adc	r19, r19
    1268:	82 0f       	add	r24, r18
    126a:	93 1f       	adc	r25, r19
    126c:	b8 01       	movw	r22, r16
    126e:	89 52       	subi	r24, 0x29	; 41
    1270:	9b 4f       	sbci	r25, 0xFB	; 251
    1272:	0e 94 27 03 	call	0x64e	; 0x64e <vListInsertEnd>
    1276:	b6 cf       	rjmp	.-148    	; 0x11e4 <vTaskIncrementTick+0xac>
    1278:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <uxMissedTicks>
    127c:	8f 5f       	subi	r24, 0xFF	; 255
    127e:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxMissedTicks>
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	1f 91       	pop	r17
    1288:	0f 91       	pop	r16
    128a:	08 95       	ret

0000128c <xTaskResumeAll>:
    128c:	ff 92       	push	r15
    128e:	0f 93       	push	r16
    1290:	1f 93       	push	r17
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	0f b6       	in	r0, 0x3f	; 63
    1298:	f8 94       	cli
    129a:	0f 92       	push	r0
    129c:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxSchedulerSuspended>
    12a0:	81 50       	subi	r24, 0x01	; 1
    12a2:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <uxSchedulerSuspended>
    12a6:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxSchedulerSuspended>
    12aa:	81 11       	cpse	r24, r1
    12ac:	5a c0       	rjmp	.+180    	; 0x1362 <xTaskResumeAll+0xd6>
    12ae:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <uxCurrentNumberOfTasks>
    12b2:	81 11       	cpse	r24, r1
    12b4:	32 c0       	rjmp	.+100    	; 0x131a <xTaskResumeAll+0x8e>
    12b6:	58 c0       	rjmp	.+176    	; 0x1368 <xTaskResumeAll+0xdc>
    12b8:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <xPendingReadyList+0x5>
    12bc:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <xPendingReadyList+0x6>
    12c0:	c6 81       	ldd	r28, Z+6	; 0x06
    12c2:	d7 81       	ldd	r29, Z+7	; 0x07
    12c4:	ce 01       	movw	r24, r28
    12c6:	0c 96       	adiw	r24, 0x0c	; 12
    12c8:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    12cc:	8e 01       	movw	r16, r28
    12ce:	0e 5f       	subi	r16, 0xFE	; 254
    12d0:	1f 4f       	sbci	r17, 0xFF	; 255
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
    12d8:	8e 89       	ldd	r24, Y+22	; 0x16
    12da:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
    12de:	98 17       	cp	r25, r24
    12e0:	10 f4       	brcc	.+4      	; 0x12e6 <xTaskResumeAll+0x5a>
    12e2:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxTopReadyPriority>
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	9c 01       	movw	r18, r24
    12ea:	22 0f       	add	r18, r18
    12ec:	33 1f       	adc	r19, r19
    12ee:	22 0f       	add	r18, r18
    12f0:	33 1f       	adc	r19, r19
    12f2:	22 0f       	add	r18, r18
    12f4:	33 1f       	adc	r19, r19
    12f6:	82 0f       	add	r24, r18
    12f8:	93 1f       	adc	r25, r19
    12fa:	b8 01       	movw	r22, r16
    12fc:	89 52       	subi	r24, 0x29	; 41
    12fe:	9b 4f       	sbci	r25, 0xFB	; 251
    1300:	0e 94 27 03 	call	0x64e	; 0x64e <vListInsertEnd>
    1304:	9e 89       	ldd	r25, Y+22	; 0x16
    1306:	e0 91 04 05 	lds	r30, 0x0504	; 0x800504 <pxCurrentTCB>
    130a:	f0 91 05 05 	lds	r31, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
    130e:	86 89       	ldd	r24, Z+22	; 0x16
    1310:	98 17       	cp	r25, r24
    1312:	20 f0       	brcs	.+8      	; 0x131c <xTaskResumeAll+0x90>
    1314:	ff 24       	eor	r15, r15
    1316:	f3 94       	inc	r15
    1318:	01 c0       	rjmp	.+2      	; 0x131c <xTaskResumeAll+0x90>
    131a:	f1 2c       	mov	r15, r1
    131c:	80 91 b8 04 	lds	r24, 0x04B8	; 0x8004b8 <xPendingReadyList>
    1320:	81 11       	cpse	r24, r1
    1322:	ca cf       	rjmp	.-108    	; 0x12b8 <xTaskResumeAll+0x2c>
    1324:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <uxMissedTicks>
    1328:	81 11       	cpse	r24, r1
    132a:	08 c0       	rjmp	.+16     	; 0x133c <xTaskResumeAll+0xb0>
    132c:	0d c0       	rjmp	.+26     	; 0x1348 <xTaskResumeAll+0xbc>
    132e:	0e 94 9c 08 	call	0x1138	; 0x1138 <vTaskIncrementTick>
    1332:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <uxMissedTicks>
    1336:	81 50       	subi	r24, 0x01	; 1
    1338:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxMissedTicks>
    133c:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <uxMissedTicks>
    1340:	81 11       	cpse	r24, r1
    1342:	f5 cf       	rjmp	.-22     	; 0x132e <xTaskResumeAll+0xa2>
    1344:	ff 24       	eor	r15, r15
    1346:	f3 94       	inc	r15
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	f8 16       	cp	r15, r24
    134c:	21 f0       	breq	.+8      	; 0x1356 <xTaskResumeAll+0xca>
    134e:	80 91 a5 04 	lds	r24, 0x04A5	; 0x8004a5 <xMissedYield>
    1352:	81 30       	cpi	r24, 0x01	; 1
    1354:	41 f4       	brne	.+16     	; 0x1366 <xTaskResumeAll+0xda>
    1356:	10 92 a5 04 	sts	0x04A5, r1	; 0x8004a5 <xMissedYield>
    135a:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <vPortYield>
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	03 c0       	rjmp	.+6      	; 0x1368 <xTaskResumeAll+0xdc>
    1362:	80 e0       	ldi	r24, 0x00	; 0
    1364:	01 c0       	rjmp	.+2      	; 0x1368 <xTaskResumeAll+0xdc>
    1366:	80 e0       	ldi	r24, 0x00	; 0
    1368:	0f 90       	pop	r0
    136a:	0f be       	out	0x3f, r0	; 63
    136c:	df 91       	pop	r29
    136e:	cf 91       	pop	r28
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	ff 90       	pop	r15
    1376:	08 95       	ret

00001378 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    137e:	89 2b       	or	r24, r25
    1380:	a9 f0       	breq	.+42     	; 0x13ac <vTaskDelay+0x34>
		{
			vTaskSuspendAll();
    1382:	0e 94 96 08 	call	0x112c	; 0x112c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1386:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <xTickCount>
    138a:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <xTickCount+0x1>
    138e:	c8 0f       	add	r28, r24
    1390:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1392:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <pxCurrentTCB>
    1396:	90 91 05 05 	lds	r25, 0x0505	; 0x800505 <pxCurrentTCB+0x1>
    139a:	02 96       	adiw	r24, 0x02	; 2
    139c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    13a0:	ce 01       	movw	r24, r28
    13a2:	0e 94 2b 07 	call	0xe56	; 0xe56 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    13a6:	0e 94 46 09 	call	0x128c	; 0x128c <xTaskResumeAll>
    13aa:	01 c0       	rjmp	.+2      	; 0x13ae <vTaskDelay+0x36>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    13ac:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    13ae:	81 11       	cpse	r24, r1
    13b0:	02 c0       	rjmp	.+4      	; 0x13b6 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    13b2:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <vPortYield>
		}
	}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	08 95       	ret

000013bc <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    13bc:	cf 93       	push	r28
    13be:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    13c0:	80 91 ae 04 	lds	r24, 0x04AE	; 0x8004ae <uxTasksDeleted>
    13c4:	88 23       	and	r24, r24
    13c6:	21 f1       	breq	.+72     	; 0x1410 <prvCheckTasksWaitingTermination+0x54>
		{
			vTaskSuspendAll();
    13c8:	0e 94 96 08 	call	0x112c	; 0x112c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13cc:	c0 91 af 04 	lds	r28, 0x04AF	; 0x8004af <xTasksWaitingTermination>
			xTaskResumeAll();
    13d0:	0e 94 46 09 	call	0x128c	; 0x128c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    13d4:	cc 23       	and	r28, r28
    13d6:	e1 f0       	breq	.+56     	; 0x1410 <prvCheckTasksWaitingTermination+0x54>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	f8 94       	cli
    13dc:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    13de:	e0 91 b4 04 	lds	r30, 0x04B4	; 0x8004b4 <xTasksWaitingTermination+0x5>
    13e2:	f0 91 b5 04 	lds	r31, 0x04B5	; 0x8004b5 <xTasksWaitingTermination+0x6>
    13e6:	c6 81       	ldd	r28, Z+6	; 0x06
    13e8:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    13ea:	ce 01       	movw	r24, r28
    13ec:	02 96       	adiw	r24, 0x02	; 2
    13ee:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListRemove>
					--uxCurrentNumberOfTasks;
    13f2:	80 91 ad 04 	lds	r24, 0x04AD	; 0x8004ad <uxCurrentNumberOfTasks>
    13f6:	81 50       	subi	r24, 0x01	; 1
    13f8:	80 93 ad 04 	sts	0x04AD, r24	; 0x8004ad <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    13fc:	80 91 ae 04 	lds	r24, 0x04AE	; 0x8004ae <uxTasksDeleted>
    1400:	81 50       	subi	r24, 0x01	; 1
    1402:	80 93 ae 04 	sts	0x04AE, r24	; 0x8004ae <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1406:	0f 90       	pop	r0
    1408:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    140a:	ce 01       	movw	r24, r28
    140c:	0e 94 98 06 	call	0xd30	; 0xd30 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	08 95       	ret

00001416 <prvIdleTask>:
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    1416:	0e 94 de 09 	call	0x13bc	; 0x13bc <prvCheckTasksWaitingTermination>
    141a:	fd cf       	rjmp	.-6      	; 0x1416 <prvIdleTask>

0000141c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    141c:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxSchedulerSuspended>
    1420:	88 23       	and	r24, r24
    1422:	49 f0       	breq	.+18     	; 0x1436 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1424:	81 e0       	ldi	r24, 0x01	; 1
    1426:	80 93 a5 04 	sts	0x04A5, r24	; 0x8004a5 <xMissedYield>
    142a:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    142c:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
    1430:	81 50       	subi	r24, 0x01	; 1
    1432:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1436:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	fc 01       	movw	r30, r24
    143e:	ee 0f       	add	r30, r30
    1440:	ff 1f       	adc	r31, r31
    1442:	ee 0f       	add	r30, r30
    1444:	ff 1f       	adc	r31, r31
    1446:	ee 0f       	add	r30, r30
    1448:	ff 1f       	adc	r31, r31
    144a:	8e 0f       	add	r24, r30
    144c:	9f 1f       	adc	r25, r31
    144e:	fc 01       	movw	r30, r24
    1450:	e9 52       	subi	r30, 0x29	; 41
    1452:	fb 4f       	sbci	r31, 0xFB	; 251
    1454:	80 81       	ld	r24, Z
    1456:	88 23       	and	r24, r24
    1458:	49 f3       	breq	.-46     	; 0x142c <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    145a:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxTopReadyPriority>
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	9c 01       	movw	r18, r24
    1462:	22 0f       	add	r18, r18
    1464:	33 1f       	adc	r19, r19
    1466:	22 0f       	add	r18, r18
    1468:	33 1f       	adc	r19, r19
    146a:	22 0f       	add	r18, r18
    146c:	33 1f       	adc	r19, r19
    146e:	28 0f       	add	r18, r24
    1470:	39 1f       	adc	r19, r25
    1472:	d9 01       	movw	r26, r18
    1474:	a9 52       	subi	r26, 0x29	; 41
    1476:	bb 4f       	sbci	r27, 0xFB	; 251
    1478:	11 96       	adiw	r26, 0x01	; 1
    147a:	ed 91       	ld	r30, X+
    147c:	fc 91       	ld	r31, X
    147e:	12 97       	sbiw	r26, 0x02	; 2
    1480:	02 80       	ldd	r0, Z+2	; 0x02
    1482:	f3 81       	ldd	r31, Z+3	; 0x03
    1484:	e0 2d       	mov	r30, r0
    1486:	12 96       	adiw	r26, 0x02	; 2
    1488:	fc 93       	st	X, r31
    148a:	ee 93       	st	-X, r30
    148c:	11 97       	sbiw	r26, 0x01	; 1
    148e:	26 52       	subi	r18, 0x26	; 38
    1490:	3b 4f       	sbci	r19, 0xFB	; 251
    1492:	e2 17       	cp	r30, r18
    1494:	f3 07       	cpc	r31, r19
    1496:	29 f4       	brne	.+10     	; 0x14a2 <vTaskSwitchContext+0x86>
    1498:	22 81       	ldd	r18, Z+2	; 0x02
    149a:	33 81       	ldd	r19, Z+3	; 0x03
    149c:	fd 01       	movw	r30, r26
    149e:	32 83       	std	Z+2, r19	; 0x02
    14a0:	21 83       	std	Z+1, r18	; 0x01
    14a2:	fc 01       	movw	r30, r24
    14a4:	ee 0f       	add	r30, r30
    14a6:	ff 1f       	adc	r31, r31
    14a8:	ee 0f       	add	r30, r30
    14aa:	ff 1f       	adc	r31, r31
    14ac:	ee 0f       	add	r30, r30
    14ae:	ff 1f       	adc	r31, r31
    14b0:	8e 0f       	add	r24, r30
    14b2:	9f 1f       	adc	r25, r31
    14b4:	fc 01       	movw	r30, r24
    14b6:	e9 52       	subi	r30, 0x29	; 41
    14b8:	fb 4f       	sbci	r31, 0xFB	; 251
    14ba:	01 80       	ldd	r0, Z+1	; 0x01
    14bc:	f2 81       	ldd	r31, Z+2	; 0x02
    14be:	e0 2d       	mov	r30, r0
    14c0:	86 81       	ldd	r24, Z+6	; 0x06
    14c2:	97 81       	ldd	r25, Z+7	; 0x07
    14c4:	90 93 05 05 	sts	0x0505, r25	; 0x800505 <pxCurrentTCB+0x1>
    14c8:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <pxCurrentTCB>
    14cc:	08 95       	ret

000014ce <__tablejump2__>:
    14ce:	ee 0f       	add	r30, r30
    14d0:	ff 1f       	adc	r31, r31
    14d2:	05 90       	lpm	r0, Z+
    14d4:	f4 91       	lpm	r31, Z
    14d6:	e0 2d       	mov	r30, r0
    14d8:	09 94       	ijmp

000014da <__umulhisi3>:
    14da:	a2 9f       	mul	r26, r18
    14dc:	b0 01       	movw	r22, r0
    14de:	b3 9f       	mul	r27, r19
    14e0:	c0 01       	movw	r24, r0
    14e2:	a3 9f       	mul	r26, r19
    14e4:	70 0d       	add	r23, r0
    14e6:	81 1d       	adc	r24, r1
    14e8:	11 24       	eor	r1, r1
    14ea:	91 1d       	adc	r25, r1
    14ec:	b2 9f       	mul	r27, r18
    14ee:	70 0d       	add	r23, r0
    14f0:	81 1d       	adc	r24, r1
    14f2:	11 24       	eor	r1, r1
    14f4:	91 1d       	adc	r25, r1
    14f6:	08 95       	ret

000014f8 <memset>:
    14f8:	dc 01       	movw	r26, r24
    14fa:	01 c0       	rjmp	.+2      	; 0x14fe <memset+0x6>
    14fc:	6d 93       	st	X+, r22
    14fe:	41 50       	subi	r20, 0x01	; 1
    1500:	50 40       	sbci	r21, 0x00	; 0
    1502:	e0 f7       	brcc	.-8      	; 0x14fc <memset+0x4>
    1504:	08 95       	ret

00001506 <strncpy>:
    1506:	fb 01       	movw	r30, r22
    1508:	dc 01       	movw	r26, r24
    150a:	41 50       	subi	r20, 0x01	; 1
    150c:	50 40       	sbci	r21, 0x00	; 0
    150e:	48 f0       	brcs	.+18     	; 0x1522 <strncpy+0x1c>
    1510:	01 90       	ld	r0, Z+
    1512:	0d 92       	st	X+, r0
    1514:	00 20       	and	r0, r0
    1516:	c9 f7       	brne	.-14     	; 0x150a <strncpy+0x4>
    1518:	01 c0       	rjmp	.+2      	; 0x151c <strncpy+0x16>
    151a:	1d 92       	st	X+, r1
    151c:	41 50       	subi	r20, 0x01	; 1
    151e:	50 40       	sbci	r21, 0x00	; 0
    1520:	e0 f7       	brcc	.-8      	; 0x151a <strncpy+0x14>
    1522:	08 95       	ret

00001524 <_exit>:
    1524:	f8 94       	cli

00001526 <__stop_program>:
    1526:	ff cf       	rjmp	.-2      	; 0x1526 <__stop_program>
